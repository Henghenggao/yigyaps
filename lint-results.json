[{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\FilterPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\Header.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\InstallButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\Pagination.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\ProtectedRoute.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\ReviewForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\ReviewList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\SearchBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\SkeletonLoader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\SkillCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\components\\UserMenu.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\contexts\\AuthContext.tsx","messages":[],"suppressedMessages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":140,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":140,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\hooks\\useSkillDetail.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\hooks\\useSkills.ts","messages":[],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'searchParams'. Either include it or remove the dependency array.","line":39,"column":8,"nodeType":"ArrayExpression","endLine":49,"endColumn":6,"suggestions":[{"desc":"Update the dependencies array to be: [searchParams.query, searchParams.category, searchParams.license, searchParams.maturity, searchParams.minRating, searchParams.maxPriceUsd, searchParams.sortBy, searchParams.limit, searchParams.offset, searchParams]","fix":{"range":[1616,1914],"text":"[searchParams.query, searchParams.category, searchParams.license, searchParams.maturity, searchParams.minRating, searchParams.maxPriceUsd, searchParams.sortBy, searchParams.limit, searchParams.offset, searchParams]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\lib\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\pages\\AuthCallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\pages\\HomePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\pages\\NotFoundPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\pages\\PublishSkillPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\pages\\SkillDetailPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\AuthContext.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\ErrorBoundary.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\InstallButton.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\Pagination.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\ReviewForm.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\SearchBar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\SkillCard.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\tests\\useSkills.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\utils\\sanitizeUrl.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\utils\\tierHelpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\src\\vitest-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\apps\\web\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\integration\\helpers\\global-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\integration\\helpers\\test-server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\integration\\routes\\concurrent-stress.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1308,1311],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1308,1311],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Concurrent Stress Tests - Race Condition Detection\n *\n * Tests limited edition minting under high concurrency to detect overselling bugs.\n * This is CRITICAL for platform credibility - limited editions must be truly limited.\n *\n * Expected Failures (until race condition is fixed):\n * - Legendary editions may exceed 10 limit\n * - Epic editions may exceed 100 limit\n *\n * License: Apache 2.0\n */\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { PostgreSqlContainer, StartedPostgreSqlContainer } from '@testcontainers/postgresql';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { migrate } from 'drizzle-orm/node-postgres/migrator';\nimport { Pool } from 'pg';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createTestJWT } from '../../unit/helpers/jwt-helpers.js';\n\nimport { createTestServer, closeTestServer, type TestServerContext } from '../helpers/test-server.js';\nimport { SkillPackageDAL, SkillMintDAL } from '@yigyaps/db';\nimport { SkillPackageFactory, SkillMintFactory } from '../../../../db/__tests__/helpers/factories.js';\nimport { sql } from 'drizzle-orm';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// Local database cleanup function for integration tests\nasync function clearDatabase(db: any) {\n  const tables = [\n    'yy_royalty_ledger',\n    'yy_skill_package_reviews',\n    'yy_skill_package_installations',\n    'yy_skill_mints',\n    'yy_skill_packages',\n  ];\n\n  for (const table of tables) {\n    await db.execute(sql.raw(`TRUNCATE TABLE ${table} RESTART IDENTITY CASCADE`));\n  }\n}\n\ndescribe('Concurrent Stress Tests - Race Condition Detection', () => {\n  let container: StartedPostgreSqlContainer;\n  let pool: Pool;\n  let testDb: ReturnType<typeof drizzle>;\n  let serverContext: TestServerContext;\n  let packageDAL: SkillPackageDAL;\n  let mintDAL: SkillMintDAL;\n\n  beforeAll(async () => {\n    // Start PostgreSQL container\n    container = await new PostgreSqlContainer('postgres:16-alpine')\n      .withDatabase('yigyaps_test')\n      .withUsername('test_user')\n      .withPassword('test_password')\n      .start();\n\n    const connectionString = container.getConnectionUri();\n    pool = new Pool({ connectionString });\n    testDb = drizzle(pool);\n\n    // Run migrations\n    const migrationsPath = path.resolve(__dirname, '../../../../db/migrations');\n    await migrate(testDb, { migrationsFolder: migrationsPath });\n\n    // Set JWT_SECRET for tests\n    process.env.JWT_SECRET = 'test-jwt-secret';\n\n    // Create test server\n    serverContext = await createTestServer(connectionString);\n\n    // Initialize DALs\n    packageDAL = new SkillPackageDAL(testDb);\n    mintDAL = new SkillMintDAL(testDb);\n  }, 120000); // 2-minute timeout for container setup\n\n  afterAll(async () => {\n    await closeTestServer(serverContext);\n    await pool.end();\n    await container.stop();\n  });\n\n  beforeEach(async () => {\n    await clearDatabase(testDb);\n  });\n\n  describe('ðŸš¨ Legendary Edition Race Condition (maxEditions: 10)', () => {\n    it('should prevent overselling under 20 concurrent requests', async () => {\n      // Setup: Create a Legendary edition package (limit: 10)\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'legendary-test',\n          priceUsd: '100.00',\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'legendary',\n          maxEditions: 10,\n          mintedCount: 0,\n        }),\n      );\n\n      // Attack: 20 concurrent installation requests\n      const concurrentRequests = 20;\n      const requests = Array.from({ length: concurrentRequests }, (_, i) =>\n        serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/installations',\n          headers: { authorization: `Bearer ${createTestJWT({ userId: `usr_test_${i}`, tier: 'legendary', role: 'user' })}` },\n          payload: {\n            packageId: pkg.id,\n            agentId: `agt_concurrent_${i}`,\n            userTier: 'free',\n          },\n        }),\n      );\n\n      // Execute all requests concurrently\n      const responses = await Promise.all(requests);\n\n      // Count successes and failures\n      const successes = responses.filter((r) => r.statusCode === 201);\n      const editionLimitErrors = responses.filter(\n        (r) => r.statusCode === 409 && JSON.parse(r.body).error === 'Edition limit reached',\n      );\n      const duplicateErrors = responses.filter(\n        (r) => r.statusCode === 409 && JSON.parse(r.body).error === 'Package already installed',\n      );\n\n      // Verify final state\n      const finalMint = await mintDAL.getBySkillPackageId(pkg.id);\n\n      console.log('\\nðŸš¨ Legendary Edition Race Condition Results:');\n      console.log(`   Concurrent requests: ${concurrentRequests}`);\n      console.log(`   Successful installations: ${successes.length}`);\n      console.log(`   Edition limit errors (409): ${editionLimitErrors.length}`);\n      console.log(`   Duplicate install errors: ${duplicateErrors.length}`);\n      console.log(`   Final mintedCount: ${finalMint?.mintedCount}`);\n      console.log(`   Expected limit: 10`);\n\n      if (successes.length > 10) {\n        console.log(`   âŒ OVERSOLD: ${successes.length - 10} extra editions!`);\n      } else {\n        console.log(`   âœ… No overselling detected`);\n      }\n\n      // Critical assertions\n      expect(finalMint?.mintedCount).toBeLessThanOrEqual(10); // Should NOT oversell\n      expect(successes.length).toBeLessThanOrEqual(10); // Should NOT accept > 10 installs\n      expect(successes.length + editionLimitErrors.length + duplicateErrors.length).toBe(\n        concurrentRequests,\n      ); // All requests accounted for\n    });\n\n    it('should handle exact limit boundary (9 â†’ 10 simultaneous requests)', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'legendary-boundary',\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'legendary',\n          maxEditions: 10,\n          mintedCount: 9, // Start at 9, only 1 spot left\n        }),\n      );\n\n      // 5 concurrent requests racing for the last spot\n      const requests = Array.from({ length: 5 }, (_, i) =>\n        serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/installations',\n          headers: { authorization: `Bearer ${createTestJWT({ userId: `usr_test_${i}`, tier: 'legendary', role: 'user' })}` },\n          payload: {\n            packageId: pkg.id,\n            agentId: `agt_boundary_${i}`,\n          },\n        }),\n      );\n\n      const responses = await Promise.all(requests);\n      const successes = responses.filter((r) => r.statusCode === 201);\n      const finalMint = await mintDAL.getBySkillPackageId(pkg.id);\n\n      console.log('\\nðŸŽ¯ Boundary Test (9 â†’ 10):');\n      console.log(`   Successful installations: ${successes.length}`);\n      console.log(`   Final mintedCount: ${finalMint?.mintedCount}`);\n\n      expect(finalMint?.mintedCount).toBe(10); // Should be exactly 10\n      expect(successes.length).toBe(1); // Only 1 request should succeed\n    });\n  });\n\n  describe('âš¡ Epic Edition Race Condition (maxEditions: 100)', () => {\n    it('should prevent overselling under 150 concurrent requests', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'epic-test',\n          priceUsd: '50.00',\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'epic',\n          maxEditions: 100,\n          mintedCount: 0,\n        }),\n      );\n\n      // Attack: 150 concurrent requests for 100 editions\n      const concurrentRequests = 150;\n      const requests = Array.from({ length: concurrentRequests }, (_, i) =>\n        serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/installations',\n          headers: { authorization: `Bearer ${createTestJWT({ userId: `usr_test_${i}`, tier: 'legendary', role: 'user' })}` },\n          payload: {\n            packageId: pkg.id,\n            agentId: `agt_epic_${i}`,\n          },\n        }),\n      );\n\n      const responses = await Promise.all(requests);\n      const successes = responses.filter((r) => r.statusCode === 201);\n      const finalMint = await mintDAL.getBySkillPackageId(pkg.id);\n\n      console.log('\\nâš¡ Epic Edition Race Condition Results:');\n      console.log(`   Concurrent requests: ${concurrentRequests}`);\n      console.log(`   Successful installations: ${successes.length}`);\n      console.log(`   Final mintedCount: ${finalMint?.mintedCount}`);\n      console.log(`   Expected limit: 100`);\n\n      if (successes.length > 100) {\n        console.log(`   âŒ OVERSOLD: ${successes.length - 100} extra editions!`);\n      }\n\n      expect(finalMint?.mintedCount).toBeLessThanOrEqual(100);\n      expect(successes.length).toBeLessThanOrEqual(100);\n    });\n  });\n\n  describe('ðŸ”¥ Rare Edition Race Condition (maxEditions: 1000)', () => {\n    it('should prevent overselling under 1200 concurrent requests', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'rare-test',\n          priceUsd: '10.00',\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'rare',\n          maxEditions: 1000,\n          mintedCount: 0,\n        }),\n      );\n\n      // Attack: 1200 concurrent requests for 1000 editions\n      const concurrentRequests = 1200;\n      const requests = Array.from({ length: concurrentRequests }, (_, i) =>\n        serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/installations',\n          headers: { authorization: `Bearer ${createTestJWT({ userId: `usr_test_${i}`, tier: 'legendary', role: 'user' })}` },\n          payload: {\n            packageId: pkg.id,\n            agentId: `agt_rare_${i}`,\n          },\n        }),\n      );\n\n      const responses = await Promise.all(requests);\n      const successes = responses.filter((r) => r.statusCode === 201);\n      const finalMint = await mintDAL.getBySkillPackageId(pkg.id);\n\n      console.log('\\nðŸ”¥ Rare Edition Race Condition Results:');\n      console.log(`   Concurrent requests: ${concurrentRequests}`);\n      console.log(`   Successful installations: ${successes.length}`);\n      console.log(`   Final mintedCount: ${finalMint?.mintedCount}`);\n      console.log(`   Expected limit: 1000`);\n\n      if (successes.length > 1000) {\n        console.log(`   âŒ OVERSOLD: ${successes.length - 1000} extra editions!`);\n      }\n\n      expect(finalMint?.mintedCount).toBeLessThanOrEqual(1000);\n      expect(successes.length).toBeLessThanOrEqual(1000);\n    }, 60000);\n  });\n\n  describe('âœ… Common Edition (No Limit)', () => {\n    it('should allow unlimited concurrent installations', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'common-test',\n          priceUsd: '0.00',\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'common',\n          maxEditions: null, // Unlimited\n          mintedCount: 0,\n        }),\n      );\n\n      // Common editions should handle any number of concurrent requests\n      const concurrentRequests = 100;\n      const requests = Array.from({ length: concurrentRequests }, (_, i) =>\n        serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/installations',\n          headers: { authorization: `Bearer ${createTestJWT({ userId: `usr_test_${i}`, tier: 'legendary', role: 'user' })}` },\n          payload: {\n            packageId: pkg.id,\n            agentId: `agt_common_${i}`,\n          },\n        }),\n      );\n\n      const responses = await Promise.all(requests);\n      const successes = responses.filter((r) => r.statusCode === 201);\n      const finalMint = await mintDAL.getBySkillPackageId(pkg.id);\n\n      console.log('\\nâœ… Common Edition (Unlimited):');\n      console.log(`   Concurrent requests: ${concurrentRequests}`);\n      console.log(`   Successful installations: ${successes.length}`);\n      console.log(`   Final mintedCount: ${finalMint?.mintedCount}`);\n\n      expect(successes.length).toBe(concurrentRequests); // All should succeed\n      expect(finalMint?.mintedCount).toBe(concurrentRequests);\n    });\n  });\n\n  describe('ðŸ“Š Performance Metrics', () => {\n    it('should complete 100 concurrent requests within reasonable time', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'perf-test',\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'epic',\n          maxEditions: 100,\n          mintedCount: 0,\n        }),\n      );\n\n      const start = Date.now();\n      const requests = Array.from({ length: 100 }, (_, i) =>\n        serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/installations',\n          headers: { authorization: `Bearer ${createTestJWT({ userId: `usr_test_${i}`, tier: 'legendary', role: 'user' })}` },\n          payload: {\n            packageId: pkg.id,\n            agentId: `agt_perf_${i}`,\n          },\n        }),\n      );\n\n      await Promise.all(requests);\n      const elapsed = Date.now() - start;\n\n      console.log(`\\nðŸ“Š Performance: 100 concurrent requests completed in ${elapsed}ms`);\n      console.log(`   Average: ${(elapsed / 100).toFixed(2)}ms per request`);\n\n      expect(elapsed).toBeLessThan(10000); // Should complete within 10 seconds\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\integration\\routes\\installations.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1134,1137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1134,1137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mint' is assigned a value but never used.","line":302,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":302,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Installations Route Integration Tests\n *\n * Tests skill package installation, uninstallation, and royalty calculation.\n * Uses Testcontainers for real PostgreSQL integration.\n *\n * License: Apache 2.0\n */\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { PostgreSqlContainer, StartedPostgreSqlContainer } from '@testcontainers/postgresql';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { migrate } from 'drizzle-orm/node-postgres/migrator';\nimport { Pool } from 'pg';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createTestServer, closeTestServer, type TestServerContext } from '../helpers/test-server.js';\nimport { SkillPackageDAL, SkillMintDAL, RoyaltyLedgerDAL } from '@yigyaps/db';\nimport { SkillPackageFactory, SkillMintFactory } from '../../../../db/__tests__/helpers/factories.js';\nimport { createTestJWT } from '../../unit/helpers/jwt-helpers.js';\nimport { sql } from 'drizzle-orm';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// Local database cleanup function for integration tests\nasync function clearDatabase(db: any) {\n  const tables = [\n    'yy_royalty_ledger',\n    'yy_skill_package_reviews',\n    'yy_skill_package_installations',\n    'yy_skill_mints',\n    'yy_skill_packages',\n  ];\n\n  for (const table of tables) {\n    await db.execute(sql.raw(`TRUNCATE TABLE ${table} RESTART IDENTITY CASCADE`));\n  }\n}\n\ndescribe('POST /v1/installations', () => {\n  let container: StartedPostgreSqlContainer;\n  let pool: Pool;\n  let testDb: ReturnType<typeof drizzle>;\n  let serverContext: TestServerContext;\n  let packageDAL: SkillPackageDAL;\n  let mintDAL: SkillMintDAL;\n  let royaltyLedgerDAL: RoyaltyLedgerDAL;\n\n  beforeAll(async () => {\n    // Start PostgreSQL container\n    container = await new PostgreSqlContainer('postgres:16-alpine')\n      .withDatabase('yigyaps_test')\n      .withUsername('test_user')\n      .withPassword('test_password')\n      .start();\n\n    const connectionString = container.getConnectionUri();\n    pool = new Pool({ connectionString });\n    testDb = drizzle(pool);\n\n    // Run migrations\n    const migrationsPath = path.resolve(__dirname, '../../../../db/migrations');\n    await migrate(testDb, { migrationsFolder: migrationsPath });\n\n    // Set JWT_SECRET for tests\n    process.env.JWT_SECRET = 'test-jwt-secret';\n\n    // Create test server\n    serverContext = await createTestServer(connectionString);\n\n    // Initialize DALs\n    packageDAL = new SkillPackageDAL(testDb);\n    mintDAL = new SkillMintDAL(testDb);\n    royaltyLedgerDAL = new RoyaltyLedgerDAL(testDb);\n  }, 120000); // 2-minute timeout for container setup\n\n  afterAll(async () => {\n    await closeTestServer(serverContext);\n    await pool.end();\n    await container.stop();\n  });\n\n  beforeEach(async () => {\n    await clearDatabase(testDb);\n  });\n\n  describe('Basic Installation', () => {\n    it('should install a free package successfully', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'test-free-pkg',\n          priceUsd: '0.00',\n          requiredTier: 0,\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_001',\n          userTier: 'free',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        packageId: pkg.id,\n        agentId: 'agt_test_001',\n        status: 'active',\n        enabled: true,\n      });\n\n      // Verify install count incremented\n      const updatedPkg = await packageDAL.getById(pkg.id);\n      expect(updatedPkg?.installCount).toBe(1);\n    });\n\n    it('should return 404 for non-existent package', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: 'non_existent_pkg',\n          agentId: 'agt_test_001',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package not found',\n      });\n    });\n  });\n\n  describe('Tier Checking', () => {\n    it('should block free tier user from installing pro package', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          requiredTier: 1, // Pro tier required\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_001',\n          userTier: 'free',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Subscription tier required',\n        requiredTier: 1,\n        currentTier: 'free',\n      });\n    });\n\n    it('should allow pro tier user to install pro package', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          requiredTier: 1, // Pro tier required\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_001',\n          userTier: 'pro',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n    });\n  });\n\n  describe('Royalty Calculation', () => {\n    it('should calculate royalty correctly for paid package', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'usr_creator_123',\n          priceUsd: '100.00',\n          requiredTier: 0, // No tier requirement\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          creatorId: 'usr_creator_123',\n          creatorRoyaltyPercent: '80.00', // 80% royalty\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_001',\n        },\n      });\n\n      if (response.statusCode !== 201) {\n        console.log('Response status:', response.statusCode);\n        console.log('Response body:', response.body);\n      }\n      expect(response.statusCode).toBe(201);\n\n      // Verify royalty ledger entry\n      const ledgers = await royaltyLedgerDAL.getByCreator('usr_creator_123');\n      expect(ledgers).toHaveLength(1);\n      expect(ledgers[0]).toMatchObject({\n        skillPackageId: pkg.id,\n        creatorId: 'usr_creator_123',\n        grossAmountUsd: '100.0000',\n        royaltyAmountUsd: '80.0000', // 80% of 100\n        royaltyPercent: '80.00',\n      });\n    });\n\n    it('should use default 70% royalty when not specified', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'usr_creator_456',\n          priceUsd: '50.00',\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          creatorId: 'usr_creator_456',\n          // creatorRoyaltyPercent not specified, should default to 70%\n        }),\n      );\n\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_002',\n        },\n      });\n\n      const ledgers = await royaltyLedgerDAL.getByCreator('usr_creator_456');\n      expect(ledgers).toHaveLength(1);\n      expect(Number(ledgers[0].royaltyAmountUsd)).toBeCloseTo(35.0, 2); // 70% of 50\n    });\n\n    it('should not create royalty entry for free package', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'usr_creator_789',\n          priceUsd: '0.00', // Free package\n          requiredTier: 0,\n        }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          creatorId: 'usr_creator_789',\n        }),\n      );\n\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_003',\n        },\n      });\n\n      // No royalty entry for free package\n      const ledgers = await royaltyLedgerDAL.getByCreator('usr_creator_789');\n      expect(ledgers).toHaveLength(0);\n    });\n  });\n\n  describe('Limited Edition Minting', () => {\n    it('should increment minted count when installing limited edition', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ requiredTier: 0 }),\n      );\n\n      const mint = await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'rare',\n          maxEditions: 1000,\n          mintedCount: 0,\n        }),\n      );\n\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_004',\n        },\n      });\n\n      const updatedMint = await mintDAL.getBySkillPackageId(pkg.id);\n      expect(updatedMint?.mintedCount).toBe(1);\n    });\n\n    it('should block installation when edition limit reached', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ requiredTier: 0 }),\n      );\n\n      await mintDAL.create(\n        SkillMintFactory.create(pkg.id, {\n          rarity: 'epic',\n          maxEditions: 2,\n          mintedCount: 2, // Limit already reached\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_005',\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Edition limit reached',\n        rarity: 'epic',\n        maxEditions: 2,\n      });\n    });\n  });\n\n  describe('Duplicate Installation Check', () => {\n    it('should block duplicate installation by same user', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ requiredTier: 0 }),\n      );\n\n      // First installation\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_006',\n        },\n      });\n\n      // Attempt duplicate installation\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/installations',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          packageId: pkg.id,\n          agentId: 'agt_test_006',\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package already installed',\n      });\n    });\n  });\n});\n\ndescribe('DELETE /v1/installations/:id', () => {\n  let container: StartedPostgreSqlContainer;\n  let pool: Pool;\n  let testDb: ReturnType<typeof drizzle>;\n  let serverContext: TestServerContext;\n  let packageDAL: SkillPackageDAL;\n\n  beforeAll(async () => {\n    container = await new PostgreSqlContainer('postgres:16-alpine')\n      .withDatabase('yigyaps_test')\n      .withUsername('test_user')\n      .withPassword('test_password')\n      .start();\n\n    const connectionString = container.getConnectionUri();\n    pool = new Pool({ connectionString });\n    testDb = drizzle(pool);\n\n    const migrationsPath = path.resolve(__dirname, '../../../../db/migrations');\n    await migrate(testDb, { migrationsFolder: migrationsPath });\n\n    process.env.JWT_SECRET = 'test-jwt-secret';\n\n    serverContext = await createTestServer(connectionString);\n    packageDAL = new SkillPackageDAL(testDb);\n  }, 120000);\n\n  afterAll(async () => {\n    await closeTestServer(serverContext);\n    await pool.end();\n    await container.stop();\n  });\n\n  beforeEach(async () => {\n    await clearDatabase(testDb);\n  });\n\n  it('should uninstall package successfully', async () => {\n    const pkg = await packageDAL.create(\n      SkillPackageFactory.create({ requiredTier: 0 }),\n    );\n\n    // Install first\n    const installResponse = await serverContext.fastify.inject({\n      method: 'POST',\n      url: '/v1/installations',\n      headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n      payload: {\n        packageId: pkg.id,\n        agentId: 'agt_test_007',\n      },\n    });\n\n    const installation = JSON.parse(installResponse.body);\n\n    // Then uninstall\n    const response = await serverContext.fastify.inject({\n      method: 'DELETE',\n      url: `/v1/installations/${installation.id}`,\n      headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n    });\n\n    expect(response.statusCode).toBe(204);\n  });\n\n  it('should return 404 for non-existent installation', async () => {\n    const response = await serverContext.fastify.inject({\n      method: 'DELETE',\n      url: '/v1/installations/non_existent_id',\n      headers: { authorization: `Bearer ${createTestJWT({ userId: 'usr_test_123', tier: 'legendary', role: 'user' })}` },\n    });\n\n    expect(response.statusCode).toBe(404);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\integration\\routes\\mints.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1101,1104],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1101,1104],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mint' is assigned a value but never used.","line":448,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":448,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'mint' is assigned a value but never used.","line":512,"column":13,"nodeType":"Identifier","messageId":"unusedVar","endLine":512,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Mints Route Integration Tests\n *\n * Tests limited edition minting, quality gates, and royalty earnings.\n * Uses Testcontainers for real PostgreSQL integration.\n *\n * License: Apache 2.0\n */\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { PostgreSqlContainer, StartedPostgreSqlContainer } from '@testcontainers/postgresql';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { migrate } from 'drizzle-orm/node-postgres/migrator';\nimport { Pool } from 'pg';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createTestJWT } from '../../unit/helpers/jwt-helpers.js';\nimport { createTestServer, closeTestServer, type TestServerContext } from '../helpers/test-server.js';\nimport { SkillPackageDAL, SkillMintDAL, RoyaltyLedgerDAL } from '@yigyaps/db';\nimport { SkillPackageFactory } from '../../../../db/__tests__/helpers/factories.js';\nimport { sql } from 'drizzle-orm';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// Local database cleanup function for integration tests\nasync function clearDatabase(db: any) {\n  const tables = [\n    'yy_royalty_ledger',\n    'yy_skill_package_reviews',\n    'yy_skill_package_installations',\n    'yy_skill_mints',\n    'yy_skill_packages',\n  ];\n\n  for (const table of tables) {\n    await db.execute(sql.raw(`TRUNCATE TABLE ${table} RESTART IDENTITY CASCADE`));\n  }\n}\n\ndescribe('Mints Routes', () => {\n  let container: StartedPostgreSqlContainer;\n  let pool: Pool;\n  let testDb: ReturnType<typeof drizzle>;\n  let serverContext: TestServerContext;\n  let packageDAL: SkillPackageDAL;\n  let mintDAL: SkillMintDAL;\n  let royaltyLedgerDAL: RoyaltyLedgerDAL;\n\n  beforeAll(async () => {\n    // Start PostgreSQL container\n    container = await new PostgreSqlContainer('postgres:16-alpine')\n      .withDatabase('yigyaps_test')\n      .withUsername('test_user')\n      .withPassword('test_password')\n      .start();\n\n    const connectionString = container.getConnectionUri();\n    pool = new Pool({ connectionString });\n    testDb = drizzle(pool);\n\n    // Run migrations\n    const migrationsPath = path.resolve(__dirname, '../../../../db/migrations');\n    await migrate(testDb, { migrationsFolder: migrationsPath });\n\n    // Set JWT_SECRET for tests (no ADMIN_SECRET needed - mints routes don't use it)\n    process.env.JWT_SECRET = 'test-jwt-secret';\n\n    // Create test server\n    serverContext = await createTestServer(connectionString);\n\n    // Initialize DALs\n    packageDAL = new SkillPackageDAL(testDb);\n    mintDAL = new SkillMintDAL(testDb);\n    royaltyLedgerDAL = new RoyaltyLedgerDAL(testDb);\n  }, 120000); // 2-minute timeout for container setup\n\n  afterAll(async () => {\n    await closeTestServer(serverContext);\n    await pool.end();\n    await container.stop();\n  });\n\n  beforeEach(async () => {\n    await clearDatabase(testDb);\n  });\n\n  describe('POST /v1/mints', () => {\n    it('should create a common mint successfully', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous', // Default userId from routes\n          packageId: 'test-common-mint',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'common',\n          creatorRoyaltyPercent: 70,\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        skillPackageId: pkg.id,\n        rarity: 'common',\n        maxEditions: null, // Common has unlimited editions\n        creatorId: 'anonymous',\n        creatorRoyaltyPercent: '70.00',\n        origin: 'manual',\n      });\n      expect(body.id).toMatch(/^smint_\\d+_[a-z0-9]{6}$/);\n    });\n\n    it('should create a rare mint with graduation certificate', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'test-rare-mint',\n        }),\n      );\n\n      const graduationCert = {\n        lab: 'yigstudio-lab',\n        version: '1.0',\n        skillId: 'test-rare-mint',\n        qualityScore: 95,\n        issuedAt: Date.now(),\n        signature: 'test-signature',\n      };\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'rare',\n          creatorRoyaltyPercent: 80,\n          graduationCertificate: graduationCert,\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        skillPackageId: pkg.id,\n        rarity: 'rare',\n        maxEditions: 1000,\n        creatorId: 'anonymous',\n        creatorRoyaltyPercent: '80.00',\n        origin: 'beta-lab',\n      });\n      expect(body.graduationCertificate).toEqual(graduationCert);\n    });\n\n    it('should create an epic mint with correct max editions', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'test-epic-mint',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'epic',\n          graduationCertificate: { verified: true },\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        rarity: 'epic',\n        maxEditions: 100,\n        origin: 'beta-lab',\n      });\n    });\n\n    it('should create a legendary mint with correct max editions', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'test-legendary-mint',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'legendary',\n          graduationCertificate: { verified: true },\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        rarity: 'legendary',\n        maxEditions: 10,\n        origin: 'beta-lab',\n      });\n    });\n\n    it('should allow custom maxEditions', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'test-custom-max',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'rare',\n          maxEditions: 500, // Custom instead of default 1000\n          graduationCertificate: { verified: true },\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body.maxEditions).toBe(500);\n    });\n\n    it('should return 404 for non-existent package', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: 'non_existent_pkg',\n          rarity: 'common',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package not found',\n      });\n    });\n\n    it('should return 403 when non-author tries to mint', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'different_author',\n          packageId: 'protected-package',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'common',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Not authorized to mint this package',\n      });\n    });\n\n    it('should return 409 for duplicate mint', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'duplicate-mint-test',\n        }),\n      );\n\n      // Create first mint\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'common',\n        },\n      });\n\n      // Attempt duplicate mint\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'rare',\n          graduationCertificate: { verified: true },\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package already minted',\n      });\n      expect(JSON.parse(response.body).mint).toBeDefined();\n    });\n\n    it('should return 422 when rare mint lacks graduation certificate', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'rare-no-cert',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'rare',\n          // Missing graduationCertificate\n        },\n      });\n\n      expect(response.statusCode).toBe(422);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'graduationCertificate is required for Rare+ minting',\n      });\n    });\n\n    it('should return 422 when epic mint lacks graduation certificate', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'epic-no-cert',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'epic',\n        },\n      });\n\n      expect(response.statusCode).toBe(422);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'graduationCertificate is required for Rare+ minting',\n      });\n    });\n\n    it('should return 422 when legendary mint lacks graduation certificate', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'legendary-no-cert',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'legendary',\n        },\n      });\n\n      expect(response.statusCode).toBe(422);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'graduationCertificate is required for Rare+ minting',\n      });\n    });\n\n    it('should accept common mint without graduation certificate', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          packageId: 'common-no-cert',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/mints',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n        payload: {\n          skillPackageId: pkg.id,\n          rarity: 'common',\n          // No graduationCertificate - should be OK for common\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body.rarity).toBe('common');\n      expect(body.graduationCertificate).toBeNull();\n    });\n  });\n\n  describe('GET /v1/mints/my-earnings', () => {\n    it('should return zero earnings for new creator', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/mints/my-earnings',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        totalUsd: '0', // getTotalEarnings returns '0' for zero, not '0.0000'\n        count: 0,\n        recent: [],\n      });\n    });\n\n    it('should return earnings summary after installations', async () => {\n      // Create package and mint\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          priceUsd: '50.00',\n          packageId: 'earnings-test',\n        }),\n      );\n\n      const mint = await mintDAL.create({\n        id: `smint_${Date.now()}_test`,\n        skillPackageId: pkg.id,\n        rarity: 'common',\n        maxEditions: null,\n        creatorId: 'anonymous',\n        creatorRoyaltyPercent: '70.00',\n        graduationCertificate: null,\n        origin: 'manual',\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      });\n\n      // Create royalty ledger entries (simulating installations)\n      await royaltyLedgerDAL.create({\n        id: `rled_${Date.now()}_001`,\n        skillPackageId: pkg.id,\n        creatorId: 'anonymous',\n        buyerId: 'buyer_001',\n        installationId: 'inst_001',\n        grossAmountUsd: '50.00',\n        royaltyAmountUsd: '35.00',\n        royaltyPercent: '70.00',\n        createdAt: Date.now(),\n      });\n\n      await royaltyLedgerDAL.create({\n        id: `rled_${Date.now()}_002`,\n        skillPackageId: pkg.id,\n        creatorId: 'anonymous',\n        buyerId: 'buyer_002',\n        installationId: 'inst_002',\n        grossAmountUsd: '50.00',\n        royaltyAmountUsd: '35.00',\n        royaltyPercent: '70.00',\n        createdAt: Date.now() + 1000,\n      });\n\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/mints/my-earnings',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.count).toBe(2);\n      expect(Number(body.totalUsd)).toBeCloseTo(70.0, 2); // 35 + 35\n      expect(body.recent).toHaveLength(2);\n      expect(body.recent[0]).toMatchObject({\n        creatorId: 'anonymous',\n        grossAmountUsd: '50.0000',\n        royaltyAmountUsd: '35.0000',\n      });\n    });\n\n    it('should limit recent earnings to 20 entries', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'anonymous',\n          priceUsd: '10.00',\n        }),\n      );\n\n      const mint = await mintDAL.create({\n        id: `smint_${Date.now()}_test`,\n        skillPackageId: pkg.id,\n        rarity: 'common',\n        maxEditions: null,\n        creatorId: 'anonymous',\n        creatorRoyaltyPercent: '70.00',\n        graduationCertificate: null,\n        origin: 'manual',\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      });\n\n      // Create 25 royalty entries\n      for (let i = 0; i < 25; i++) {\n        await royaltyLedgerDAL.create({\n          id: `rled_${Date.now()}_${i}`,\n          skillPackageId: pkg.id,\n          creatorId: 'anonymous',\n          buyerId: `buyer_${i}`,\n          installationId: `inst_${i}`,\n          grossAmountUsd: '10.00',\n          royaltyAmountUsd: '7.00',\n          royaltyPercent: '70.00',\n          createdAt: Date.now() + i,\n        });\n      }\n\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/mints/my-earnings',\n        headers: { authorization: `Bearer ${createTestJWT({ userId: 'anonymous', tier: 'legendary', role: 'user' })}` },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.count).toBe(25);\n      expect(body.recent).toHaveLength(20); // Limited to 20\n      expect(Number(body.totalUsd)).toBeCloseTo(175.0, 2); // 25 * 7\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\integration\\routes\\packages.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1070,1073],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1070,1073],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6902,6905],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6902,6905],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":257,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":257,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8142,8145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8142,8145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9450,9453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9450,9453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Packages Route Integration Tests\n *\n * Tests skill package CRUD operations, search, and access control.\n * Uses Testcontainers for real PostgreSQL integration.\n *\n * License: Apache 2.0\n */\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { PostgreSqlContainer, StartedPostgreSqlContainer } from '@testcontainers/postgresql';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { migrate } from 'drizzle-orm/node-postgres/migrator';\nimport { Pool } from 'pg';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createTestServer, closeTestServer, type TestServerContext } from '../helpers/test-server.js';\nimport { createAdminJWT } from '../../unit/helpers/jwt-helpers.js';\nimport { SkillPackageDAL } from '@yigyaps/db';\nimport { SkillPackageFactory } from '../../../../db/__tests__/helpers/factories.js';\nimport { sql } from 'drizzle-orm';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// Local database cleanup function for integration tests\nasync function clearDatabase(db: any) {\n  const tables = [\n    'yy_royalty_ledger',\n    'yy_skill_package_reviews',\n    'yy_skill_package_installations',\n    'yy_skill_mints',\n    'yy_skill_packages',\n  ];\n\n  for (const table of tables) {\n    await db.execute(sql.raw(`TRUNCATE TABLE ${table} RESTART IDENTITY CASCADE`));\n  }\n}\n\ndescribe('Packages Routes', () => {\n  let container: StartedPostgreSqlContainer;\n  let pool: Pool;\n  let testDb: ReturnType<typeof drizzle>;\n  let serverContext: TestServerContext;\n  let packageDAL: SkillPackageDAL;\n\n  beforeAll(async () => {\n    // Start PostgreSQL container\n    container = await new PostgreSqlContainer('postgres:16-alpine')\n      .withDatabase('yigyaps_test')\n      .withUsername('test_user')\n      .withPassword('test_password')\n      .start();\n\n    const connectionString = container.getConnectionUri();\n    pool = new Pool({ connectionString });\n    testDb = drizzle(pool);\n\n    // Run migrations\n    const migrationsPath = path.resolve(__dirname, '../../../../db/migrations');\n    await migrate(testDb, { migrationsFolder: migrationsPath });\n\n    // Set JWT_SECRET and ADMIN_SECRET for tests\n    process.env.JWT_SECRET = 'test-jwt-secret';\n    // ADMIN_SECRET removed\n\n    // Create test server\n    serverContext = await createTestServer(connectionString);\n\n    // Initialize DAL\n    packageDAL = new SkillPackageDAL(testDb);\n  }, 120000); // 2-minute timeout for container setup\n\n  afterAll(async () => {\n    await closeTestServer(serverContext);\n    await pool.end();\n    await container.stop();\n  });\n\n  beforeEach(async () => {\n    await clearDatabase(testDb);\n  });\n\n  describe('POST /v1/packages', () => {\n    it('should create a new package with admin auth', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/packages',\n        headers: {\n          authorization: `Bearer ${createAdminJWT()}`,\n        },\n        payload: {\n          packageId: 'test-package',\n          version: '1.0.0',\n          displayName: 'Test Package',\n          description: 'A test package for integration testing',\n          authorName: 'Test Author',\n          license: 'open-source',\n          category: 'development',\n          maturity: 'stable',\n          mcpTransport: 'stdio',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        packageId: 'test-package',\n        version: '1.0.0',\n        displayName: 'Test Package',\n        description: 'A test package for integration testing',\n        authorName: 'Test Author',\n        license: 'open-source',\n        category: 'development',\n      });\n      expect(body.id).toMatch(/^spkg_\\d+_[a-z0-9]{6}$/);\n    });\n\n    it('should return 409 for duplicate packageId', async () => {\n      // Create first package\n      await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'duplicate-pkg' }),\n      );\n\n      // Attempt to create duplicate\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/packages',\n        headers: {\n          authorization: `Bearer ${createAdminJWT()}`,\n        },\n        payload: {\n          packageId: 'duplicate-pkg',\n          version: '1.0.0',\n          displayName: 'Duplicate Package',\n          description: 'This should fail due to duplicate packageId',\n          authorName: 'Test Author',\n        },\n      });\n\n      expect(response.statusCode).toBe(409);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package ID already exists',\n        packageId: 'duplicate-pkg',\n      });\n    });\n\n    it('should return 401 without admin auth', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/packages',\n        payload: {\n          packageId: 'test-package',\n          version: '1.0.0',\n          displayName: 'Test Package',\n          description: 'This should fail without auth',\n          authorName: 'Test Author',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n\n  describe('GET /v1/packages', () => {\n    beforeEach(async () => {\n      // Create test packages\n      await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'search-test-1',\n          displayName: 'Search Test 1',\n          category: 'development',\n          license: 'open-source',\n          maturity: 'stable',\n          priceUsd: '0.00',\n        }),\n      );\n      await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'search-test-2',\n          displayName: 'Search Test 2',\n          category: 'productivity',\n          license: 'premium',\n          maturity: 'beta',\n          priceUsd: '9.99',\n        }),\n      );\n      await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'search-test-3',\n          displayName: 'Search Test 3',\n          category: 'development',\n          license: 'free',\n          maturity: 'experimental',\n          priceUsd: '0.00',\n        }),\n      );\n    });\n\n    it('should return all packages without filters', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages).toHaveLength(3);\n      expect(body.total).toBe(3);\n    });\n\n    it('should filter by category', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages?category=development',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages).toHaveLength(2);\n      expect(body.packages.every((pkg: any) => pkg.category === 'development')).toBe(true);\n    });\n\n    it('should filter by license', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages?license=premium',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages).toHaveLength(1);\n      expect(body.packages[0].license).toBe('premium');\n    });\n\n    it('should filter by maturity', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages?maturity=stable',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages).toHaveLength(1);\n      expect(body.packages[0].maturity).toBe('stable');\n    });\n\n    it('should filter by maxPriceUsd', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages?maxPriceUsd=5',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages).toHaveLength(2); // Only free packages (0.00 <= 5)\n      expect(body.packages.every((pkg: any) => parseFloat(pkg.priceUsd) <= 5)).toBe(true);\n    });\n\n    it('should handle pagination with limit and offset', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages?limit=2&offset=1',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages).toHaveLength(2);\n      expect(body.total).toBe(3);\n      // Note: search() returns { packages, total } without limit/offset fields\n    });\n\n    it('should support query search', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages?query=Search%20Test%202',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages.length).toBeGreaterThan(0);\n    });\n\n    it('should support different sort orders', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages?sortBy=name',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body.packages).toHaveLength(3);\n      // Names should be in alphabetical order\n      const names = body.packages.map((pkg: any) => pkg.displayName);\n      expect(names).toEqual([...names].sort());\n    });\n  });\n\n  describe('GET /v1/packages/:id', () => {\n    it('should return package by id', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'get-by-id-test',\n          displayName: 'Get By ID Test',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: `/v1/packages/${pkg.id}`,\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        id: pkg.id,\n        packageId: 'get-by-id-test',\n        displayName: 'Get By ID Test',\n      });\n    });\n\n    it('should return 404 for non-existent package', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages/non_existent_id',\n      });\n\n      expect(response.statusCode).toBe(404);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package not found',\n      });\n    });\n  });\n\n  describe('GET /v1/packages/by-pkg/:packageId', () => {\n    it('should return package by packageId', async () => {\n      await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'unique-package-id',\n          displayName: 'Unique Package',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages/by-pkg/unique-package-id',\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        packageId: 'unique-package-id',\n        displayName: 'Unique Package',\n      });\n    });\n\n    it('should return 404 for non-existent packageId', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: '/v1/packages/by-pkg/non-existent-package',\n      });\n\n      expect(response.statusCode).toBe(404);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package not found',\n      });\n    });\n  });\n\n  describe('PATCH /v1/packages/:id', () => {\n    it('should update package by author', async () => {\n      const authorId = 'usr_admin_001';\n\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: authorId,\n          displayName: 'Original Name',\n          description: 'Original description',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'PATCH',\n        url: `/v1/packages/${pkg.id}`,\n        headers: {\n          authorization: `Bearer ${createAdminJWT()}`,\n        },\n        payload: {\n          displayName: 'Updated Name',\n          description: 'Updated description',\n        },\n      });\n\n      expect(response.statusCode).toBe(200);\n      const body = JSON.parse(response.body);\n      expect(body).toMatchObject({\n        id: pkg.id,\n        displayName: 'Updated Name',\n        description: 'Updated description',\n      });\n    });\n\n    it('should return 403 when non-author tries to update', async () => {\n      // Phase 1 limitation: requireAdminAuth always uses 'anonymous' as userId\n      // So we create a package with a different author to test 403\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'different_author',\n          displayName: 'Protected Package',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'PATCH',\n        url: `/v1/packages/${pkg.id}`,\n        headers: {\n          authorization: `Bearer ${createAdminJWT()}`,\n        },\n        payload: {\n          displayName: 'Unauthorized Update',\n        },\n      });\n\n      expect(response.statusCode).toBe(403);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Not authorized to update this package',\n      });\n    });\n\n    it('should return 404 for non-existent package', async () => {\n      const response = await serverContext.fastify.inject({\n        method: 'PATCH',\n        url: '/v1/packages/non_existent_id',\n        headers: {\n          authorization: `Bearer ${createAdminJWT()}`,\n        },\n        payload: {\n          displayName: 'Update Non-existent',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n      expect(JSON.parse(response.body)).toMatchObject({\n        error: 'Package not found',\n      });\n    });\n\n    it('should return 401 without admin auth', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          author: 'usr_author_003',\n        }),\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'PATCH',\n        url: `/v1/packages/${pkg.id}`,\n        payload: {\n          displayName: 'Unauthorized Update',\n        },\n      });\n\n      expect(response.statusCode).toBe(401);\n    });\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\integration\\routes\\reviews.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createAdminJWT' is defined but never used.","line":20,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":24,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"createAdminJWT"},"fix":{"range":[869,884],"text":""},"desc":"Remove unused variable \"createAdminJWT\"."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1134,1137],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1134,1137],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'reviewDAL' is assigned a value but never used.","line":46,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":46,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reviews Route Integration Tests\n *\n * Tests review submission, retrieval, rating calculation, and verified badges.\n * Uses Testcontainers for real PostgreSQL integration.\n *\n * License: Apache 2.0\n */\n\nimport { describe, it, expect, beforeAll, afterAll, beforeEach } from 'vitest';\nimport { PostgreSqlContainer, StartedPostgreSqlContainer } from '@testcontainers/postgresql';\nimport { drizzle } from 'drizzle-orm/node-postgres';\nimport { migrate } from 'drizzle-orm/node-postgres/migrator';\nimport { Pool } from 'pg';\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport { createTestServer, closeTestServer, type TestServerContext } from '../helpers/test-server.js';\nimport { SkillPackageDAL, SkillReviewDAL, SkillInstallationDAL } from '@yigyaps/db';\nimport { SkillPackageFactory } from '../../../../db/__tests__/helpers/factories.js';\nimport { createAdminJWT, createTestJWT } from '../../unit/helpers/jwt-helpers.js';\nimport { sql } from 'drizzle-orm';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\n\n// Local database cleanup function for integration tests\nasync function clearDatabase(db: any) {\n  const tables = [\n    'yy_royalty_ledger',\n    'yy_skill_package_reviews',\n    'yy_skill_package_installations',\n    'yy_skill_mints',\n    'yy_skill_packages',\n  ];\n\n  for (const table of tables) {\n    await db.execute(sql.raw(`TRUNCATE TABLE ${table} RESTART IDENTITY CASCADE`));\n  }\n}\n\ndescribe('Reviews Routes Integration Tests', () => {\n  let container: StartedPostgreSqlContainer;\n  let pool: Pool;\n  let testDb: ReturnType<typeof drizzle>;\n  let serverContext: TestServerContext;\n  let packageDAL: SkillPackageDAL;\n  let reviewDAL: SkillReviewDAL;\n  let installDAL: SkillInstallationDAL;\n\n  beforeAll(async () => {\n    // Start PostgreSQL container\n    container = await new PostgreSqlContainer('postgres:16-alpine')\n      .withDatabase('yigyaps_test')\n      .withUsername('test_user')\n      .withPassword('test_password')\n      .start();\n\n    const connectionString = container.getConnectionUri();\n    pool = new Pool({ connectionString });\n    testDb = drizzle(pool);\n\n    // Run migrations\n    const migrationsPath = path.resolve(__dirname, '../../../../db/migrations');\n    await migrate(testDb, { migrationsFolder: migrationsPath });\n\n    // Set environment variables for tests\n    process.env.JWT_SECRET = 'test-jwt-secret';\n    // ADMIN_SECRET removed\n\n    // Create test server\n    serverContext = await createTestServer(connectionString);\n\n    // Initialize DAL\n    packageDAL = new SkillPackageDAL(testDb);\n    reviewDAL = new SkillReviewDAL(testDb);\n    installDAL = new SkillInstallationDAL(testDb);\n  }, 120000);\n\n  afterAll(async () => {\n    await closeTestServer(serverContext);\n    await pool.end();\n    await container.stop();\n  });\n\n  beforeEach(async () => {\n    await clearDatabase(testDb);\n  });\n\n  describe('POST /v1/reviews', () => {\n    it('should create a review with verified badge when user has installed the package', async () => {\n      // Create a test package\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'test-author/test-package',\n          author: 'usr_author_123',\n        })\n      );\n\n      // Create an installation to mark user as verified\n      const userId = 'usr_test_reviewer';\n      await installDAL.install({\n        id: `spi_${Date.now()}_test`,\n        packageId: pkg.id,\n        packageVersion: '1.0.0',\n        agentId: 'agt_test_agent',\n        userId,\n        status: 'active',\n        enabled: true,\n        configuration: null,\n        errorMessage: null,\n        installedAt: Date.now(),\n        uninstalledAt: null,\n      });\n\n      const jwt = createTestJWT({ userId, userName: 'Test Reviewer' });\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 5,\n          title: 'Excellent Package',\n          comment: 'This package is amazing and works perfectly for my use case!',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const review = JSON.parse(response.payload);\n      expect(review.rating).toBe(5);\n      expect(review.verified).toBe(true);\n      expect(review.title).toBe('Excellent Package');\n\n      // Verify rating stats were updated\n      const updatedPkg = await packageDAL.getById(pkg.id);\n      expect(Number(updatedPkg?.rating)).toBe(5);\n      expect(updatedPkg?.reviewCount).toBe(1);\n    });\n\n    it('should create a review without verified badge when user has not installed', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({\n          packageId: 'test-author/test-package-2',\n          author: 'usr_author_456',\n        })\n      );\n\n      const userId = 'usr_unverified_reviewer';\n      const jwt = createTestJWT({ userId, userName: 'Unverified Reviewer' });\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 4,\n          comment: 'Good package, but I have not installed it yet.',\n        },\n      });\n\n      expect(response.statusCode).toBe(201);\n      const review = JSON.parse(response.payload);\n      expect(review.verified).toBe(false);\n      expect(review.rating).toBe(4);\n    });\n\n    it('should reject review with invalid rating (below 1)', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/test-package-3' })\n      );\n\n      const jwt = createTestJWT({ userId: 'usr_test_123' });\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 0,\n          comment: 'Invalid rating test',\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should reject review with invalid rating (above 5)', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/test-package-4' })\n      );\n\n      const jwt = createTestJWT({ userId: 'usr_test_456' });\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 6,\n          comment: 'Invalid rating test',\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should reject review with title too short (< 3 chars)', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/test-package-5' })\n      );\n\n      const jwt = createTestJWT({ userId: 'usr_test_789' });\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 3,\n          title: 'OK', // Too short\n          comment: 'This is a valid comment',\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should reject review with comment too short (< 10 chars)', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/test-package-6' })\n      );\n\n      const jwt = createTestJWT({ userId: 'usr_test_101' });\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 3,\n          comment: 'Short', // Too short\n        },\n      });\n\n      expect(response.statusCode).toBe(400);\n    });\n\n    it('should return 404 when package does not exist', async () => {\n      const jwt = createTestJWT({ userId: 'usr_test_404' });\n\n      const response = await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt}` },\n        payload: {\n          packageId: 'spkg_nonexistent',\n          packageVersion: '1.0.0',\n          rating: 5,\n          comment: 'This should fail',\n        },\n      });\n\n      expect(response.statusCode).toBe(404);\n      const error = JSON.parse(response.payload);\n      expect(error.error).toBe('Package not found');\n    });\n\n    it('should calculate average rating correctly with multiple reviews', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/test-package-7' })\n      );\n\n      const jwt1 = createTestJWT({ userId: 'usr_reviewer_1' });\n      const jwt2 = createTestJWT({ userId: 'usr_reviewer_2' });\n      const jwt3 = createTestJWT({ userId: 'usr_reviewer_3' });\n\n      // Review 1: Rating 5\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt1}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 5,\n          comment: 'Excellent!',\n        },\n      });\n\n      // Review 2: Rating 4\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt2}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 4,\n          comment: 'Very good package!',\n        },\n      });\n\n      // Review 3: Rating 3\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt3}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 3,\n          comment: 'Decent package',\n        },\n      });\n\n      // Check average: (5 + 4 + 3) / 3 = 4.0\n      const updatedPkg = await packageDAL.getById(pkg.id);\n      expect(Number(updatedPkg?.rating)).toBe(4);\n      expect(updatedPkg?.reviewCount).toBe(3);\n    });\n  });\n\n  describe('GET /v1/reviews/:packageId', () => {\n    it('should return reviews for a package', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/test-package-get' })\n      );\n\n      // Create multiple reviews\n      const jwt1 = createTestJWT({ userId: 'usr_rev_1', userName: 'Reviewer One' });\n      const jwt2 = createTestJWT({ userId: 'usr_rev_2', userName: 'Reviewer Two' });\n\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt1}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 5,\n          comment: 'First review',\n        },\n      });\n\n      await serverContext.fastify.inject({\n        method: 'POST',\n        url: '/v1/reviews',\n        headers: { authorization: `Bearer ${jwt2}` },\n        payload: {\n          packageId: pkg.id,\n          packageVersion: '1.0.0',\n          rating: 4,\n          comment: 'Second review',\n        },\n      });\n\n      // Get reviews\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: `/v1/reviews/${pkg.id}`,\n      });\n\n      expect(response.statusCode).toBe(200);\n      const data = JSON.parse(response.payload);\n      expect(data.reviews).toHaveLength(2);\n      expect(data.reviews[0].userName).toMatch(/Reviewer (One|Two)/);\n    });\n\n    it('should return empty array when no reviews exist', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/no-reviews' })\n      );\n\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: `/v1/reviews/${pkg.id}`,\n      });\n\n      expect(response.statusCode).toBe(200);\n      const data = JSON.parse(response.payload);\n      expect(data.reviews).toHaveLength(0);\n    });\n\n    it('should paginate reviews correctly with limit and offset', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/pagination-test' })\n      );\n\n      // Create 5 reviews\n      for (let i = 1; i <= 5; i++) {\n        const jwt = createTestJWT({ userId: `usr_rev_${i}` });\n        await serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/reviews',\n          headers: { authorization: `Bearer ${jwt}` },\n          payload: {\n            packageId: pkg.id,\n            packageVersion: '1.0.0',\n            rating: i,\n            comment: `Review number ${i}`,\n          },\n        });\n      }\n\n      // Test limit\n      const response1 = await serverContext.fastify.inject({\n        method: 'GET',\n        url: `/v1/reviews/${pkg.id}?limit=2`,\n      });\n      expect(response1.statusCode).toBe(200);\n      const data1 = JSON.parse(response1.payload);\n      expect(data1.reviews).toHaveLength(2);\n\n      // Test offset\n      const response2 = await serverContext.fastify.inject({\n        method: 'GET',\n        url: `/v1/reviews/${pkg.id}?limit=2&offset=2`,\n      });\n      expect(response2.statusCode).toBe(200);\n      const data2 = JSON.parse(response2.payload);\n      expect(data2.reviews).toHaveLength(2);\n\n      // Test offset beyond total\n      const response3 = await serverContext.fastify.inject({\n        method: 'GET',\n        url: `/v1/reviews/${pkg.id}?offset=10`,\n      });\n      expect(response3.statusCode).toBe(200);\n      const data3 = JSON.parse(response3.payload);\n      expect(data3.reviews).toHaveLength(0);\n    });\n\n    it('should respect max limit of 100 reviews', async () => {\n      const pkg = await packageDAL.create(\n        SkillPackageFactory.create({ packageId: 'test-author/max-limit' })\n      );\n\n      // Create 20 reviews\n      for (let i = 1; i <= 20; i++) {\n        const jwt = createTestJWT({ userId: `usr_bulk_${i}` });\n        await serverContext.fastify.inject({\n          method: 'POST',\n          url: '/v1/reviews',\n          headers: { authorization: `Bearer ${jwt}` },\n          payload: {\n            packageId: pkg.id,\n            packageVersion: '1.0.0',\n            rating: 5,\n            comment: `Bulk review ${i}`,\n          },\n        });\n      }\n\n      // Request 200 but should only get 100 max\n      const response = await serverContext.fastify.inject({\n        method: 'GET',\n        url: `/v1/reviews/${pkg.id}?limit=200`,\n      });\n\n      expect(response.statusCode).toBe(200);\n      const data = JSON.parse(response.payload);\n      expect(data.reviews.length).toBeLessThanOrEqual(100);\n    });\n  });\n});\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\unit\\helpers\\jwt-helpers.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\__tests__\\unit\\middleware\\auth-v2.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'crypto' is defined but never used.","line":14,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":14,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"crypto"},"fix":{"range":[542,571],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[863,866],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[863,866],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1037,1040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1037,1040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1403,1406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1403,1406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1801,1804],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1801,1804],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1858,1861],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1858,1861],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1937,1940],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1937,1940],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2415,2418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2415,2418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2433,2436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2433,2436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2867,2870],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2867,2870],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2885,2888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2885,2888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3318,3321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3318,3321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3336,3339],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3336,3339],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3869,3872],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3869,3872],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3887,3890],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3887,3890],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4174,4177],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4174,4177],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4192,4195],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4192,4195],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4493,4496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4493,4496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4511,4514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4511,4514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4793,4796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4793,4796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":163,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":163,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4811,4814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4811,4814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5314,5317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5314,5317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":183,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":183,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5332,5335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5332,5335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5793,5796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5793,5796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":197,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":197,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5811,5814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5811,5814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6253,6256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6253,6256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6271,6274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6271,6274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6709,6712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6709,6712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6727,6730],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6727,6730],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7351,7354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7351,7354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7369,7372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7369,7372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7793,7796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7793,7796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7811,7814],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7811,7814],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8526,8529],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8526,8529],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8544,8547],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8544,8547],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":35,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Authentication Middleware Tests (Phase 2)\n *\n * Comprehensive tests for JWT, API Key, and ADMIN_SECRET authentication.\n * Tests both optionalAuth and requireAuth middleware.\n *\n * License: Apache 2.0\n */\n\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { optionalAuth, requireAuth, type UserContext } from '../../../src/middleware/auth-v2.js';\nimport { createTestJWT, createAdminJWT, createExpiredJWT } from '../helpers/jwt-helpers.js';\nimport type { FastifyRequest, FastifyReply, FastifyBaseLogger } from 'fastify';\nimport crypto from 'crypto';\n\n// â”€â”€â”€ Mock Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ninterface MockRequest extends Partial<FastifyRequest> {\n  headers: Record<string, string | undefined>;\n  user?: UserContext;\n  cookies: Record<string, string | undefined>;\n  log: FastifyBaseLogger;\n  server: any; // Allow any for mock server to bypass FastifyInstance strict requirements\n}\n\ninterface MockReply extends Partial<FastifyReply> {\n  statusCode?: number;\n  sentPayload?: any;\n}\n\nfunction createMockRequest(authHeader?: string): MockRequest {\n  return {\n    headers: authHeader ? { authorization: authHeader } : {},\n    cookies: {},\n    log: {\n      warn: () => { },\n      info: () => { },\n      error: () => { },\n      debug: () => { },\n      fatal: () => { },\n      trace: () => { },\n      silent: () => { },\n      child: () => ({}) as any,\n      level: 'info',\n    } as unknown as FastifyBaseLogger,\n    server: {\n      db: {}, // Mock database connection\n    },\n  } as MockRequest;\n}\n\nfunction createMockReply(): MockReply {\n  const reply: MockReply = {\n    statusCode: 200,\n    sentPayload: null,\n  };\n\n  reply.status = function (this: MockReply, code: number) {\n    this.statusCode = code;\n    return this as FastifyReply;\n  } as any;\n\n  reply.send = function (this: MockReply, payload: any) {\n    this.sentPayload = payload;\n    return this as FastifyReply;\n  } as any;\n\n  return reply;\n}\n\n// â”€â”€â”€ optionalAuth Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('optionalAuth', () => {\n  beforeEach(() => {\n    // Set JWT_SECRET for tests\n    process.env.JWT_SECRET = 'test-secret-key-for-jwt-testing';\n  });\n\n  it('should continue without user context when no Authorization header', async () => {\n    const mockRequest = createMockRequest();\n    const mockReply = createMockReply();\n\n    await optionalAuth(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toBeUndefined();\n  });\n\n  it('should attach user context from valid JWT', async () => {\n    const token = createTestJWT({\n      userId: 'usr_123',\n      userName: 'John Doe',\n      githubUsername: 'johndoe',\n      tier: 'pro',\n      role: 'user',\n    });\n\n    const mockRequest = createMockRequest(`Bearer ${token}`);\n    const mockReply = createMockReply();\n\n    await optionalAuth(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toMatchObject({\n      userId: 'usr_123',\n      userName: 'John Doe',\n      tier: 'pro',\n      role: 'user',\n      authMethod: 'jwt',\n    });\n  });\n\n  it('should attach admin user context from valid JWT', async () => {\n    const token = createAdminJWT();\n\n    const mockRequest = createMockRequest(`Bearer ${token}`);\n    const mockReply = createMockReply();\n\n    await optionalAuth(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toMatchObject({\n      userId: 'usr_admin_001',\n      role: 'admin',\n      tier: 'legendary',\n      authMethod: 'jwt',\n    });\n  });\n\n  it('should continue without user context for expired JWT', async () => {\n    const token = createExpiredJWT();\n\n    // Wait a bit to ensure token is expired\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    const mockRequest = createMockRequest(`Bearer ${token}`);\n    const mockReply = createMockReply();\n\n    await optionalAuth(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toBeUndefined();\n  });\n\n  it('should continue without user context for invalid JWT', async () => {\n    const mockRequest = createMockRequest('Bearer invalid.token.here');\n    const mockReply = createMockReply();\n\n    await optionalAuth(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toBeUndefined();\n  });\n\n  it('should continue without user context for invalid Authorization format', async () => {\n    const mockRequest = createMockRequest('InvalidFormat token123');\n    const mockReply = createMockReply();\n\n    await optionalAuth(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toBeUndefined();\n  });\n\n  it('should continue without user context when Bearer token is missing', async () => {\n    const mockRequest = createMockRequest('Bearer ');\n    const mockReply = createMockReply();\n\n    await optionalAuth(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toBeUndefined();\n  });\n\n\n});\n\n// â”€â”€â”€ requireAuth Tests â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\ndescribe('requireAuth', () => {\n  beforeEach(() => {\n    process.env.JWT_SECRET = 'test-secret-key-for-jwt-testing';\n  });\n\n  it('should return 401 when no Authorization header', async () => {\n    const mockRequest = createMockRequest();\n    const mockReply = createMockReply();\n\n    const middleware = requireAuth();\n    await middleware(mockRequest as any, mockReply as any);\n\n    expect(mockReply.statusCode).toBe(401);\n    expect(mockReply.sentPayload).toMatchObject({\n      error: 'Unauthorized',\n      message: 'Missing or invalid authentication token',\n    });\n  });\n\n  it('should return 401 for invalid Authorization format', async () => {\n    const mockRequest = createMockRequest('InvalidFormat token123');\n    const mockReply = createMockReply();\n\n    const middleware = requireAuth();\n    await middleware(mockRequest as any, mockReply as any);\n\n    expect(mockReply.statusCode).toBe(401);\n    expect(mockReply.sentPayload).toMatchObject({\n      error: 'Unauthorized',\n      message: 'Missing or invalid authentication token',\n    });\n  });\n\n  it('should return 401 when Bearer token is missing', async () => {\n    const mockRequest = createMockRequest('Bearer ');\n    const mockReply = createMockReply();\n\n    const middleware = requireAuth();\n    await middleware(mockRequest as any, mockReply as any);\n\n    expect(mockReply.statusCode).toBe(401);\n  });\n\n  it('should attach user context from valid JWT', async () => {\n    const token = createTestJWT({\n      userId: 'usr_456',\n      userName: 'Jane Smith',\n      tier: 'epic',\n      role: 'user',\n    });\n\n    const mockRequest = createMockRequest(`Bearer ${token}`);\n    const mockReply = createMockReply();\n\n    const middleware = requireAuth();\n    await middleware(mockRequest as any, mockReply as any);\n\n    expect(mockRequest.user).toMatchObject({\n      userId: 'usr_456',\n      userName: 'Jane Smith',\n      tier: 'epic',\n      role: 'user',\n      authMethod: 'jwt',\n    });\n    expect(mockReply.statusCode).toBe(200); // No error\n  });\n\n  it('should return 403 for expired JWT', async () => {\n    const token = createExpiredJWT();\n\n    // Wait a bit to ensure token is expired\n    await new Promise((resolve) => setTimeout(resolve, 100));\n\n    const mockRequest = createMockRequest(`Bearer ${token}`);\n    const mockReply = createMockReply();\n\n    const middleware = requireAuth();\n    await middleware(mockRequest as any, mockReply as any);\n\n    expect(mockReply.statusCode).toBe(403);\n    expect(mockReply.sentPayload).toMatchObject({\n      error: 'Forbidden',\n      message: 'Invalid credentials',\n    });\n  });\n\n  it('should return 403 for invalid JWT', async () => {\n    const mockRequest = createMockRequest('Bearer invalid.token.here');\n    const mockReply = createMockReply();\n\n    const middleware = requireAuth();\n    await middleware(mockRequest as any, mockReply as any);\n\n    expect(mockReply.statusCode).toBe(403);\n    expect(mockReply.sentPayload).toMatchObject({\n      error: 'Forbidden',\n      message: 'Invalid credentials',\n    });\n  });\n\n\n\n  it('should handle different user tiers correctly', async () => {\n    const tiers: Array<'free' | 'pro' | 'epic' | 'legendary'> = [\n      'free',\n      'pro',\n      'epic',\n      'legendary',\n    ];\n\n    for (const tier of tiers) {\n      const token = createTestJWT({\n        userId: `usr_${tier}`,\n        tier,\n        role: 'user',\n      });\n\n      const mockRequest = createMockRequest(`Bearer ${token}`);\n      const mockReply = createMockReply();\n\n      const middleware = requireAuth();\n      await middleware(mockRequest as any, mockReply as any);\n\n      expect(mockRequest.user?.tier).toBe(tier);\n    }\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\fastify.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\lib\\ckks.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'key' is assigned a value but never used.","line":55,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * CKKS Homomorphic Encryption PoC (Simulation)\r\n * \r\n * Demonstrates the concept of \"Computing on Encrypted Data\" where\r\n * a Virtual Room can process rules without ever knowing the plaintext.\r\n * \r\n * Note: This is an architectural simulation for Phase 0. \r\n * Phase 1 will integrate a real HE library (e.g., SEAL-WASM).\r\n * \r\n * License: Apache 2.0\r\n */\r\n\r\nimport crypto from \"crypto\";\r\n\r\nexport class CKKSPoC {\r\n    /**\r\n     * Simulate encoding and encrypting a value (e.g., a rule threshold or a score)\r\n     */\r\n    static encrypt(value: number): { ciphertext: string; iv: string } {\r\n        // In real CKKS, this would be a polynomial encryption.\r\n        // Here we use AES but prefix it with a \"CKKS_\" tag to signal the simulator.\r\n        const iv = crypto.randomBytes(16);\r\n        const key = crypto.createHash('sha256').update(\"poc-ckks-key\").digest();\r\n        const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\r\n        let encrypted = cipher.update(value.toString());\r\n        encrypted = Buffer.concat([encrypted, cipher.final()]);\r\n\r\n        return {\r\n            ciphertext: `CKKS_${encrypted.toString('hex')}`,\r\n            iv: iv.toString('hex')\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Simulate a Homomorphic Addition on Ciphertexts\r\n     * (Adds two encrypted values without decrypting them)\r\n     */\r\n    static homomorphicAdd(c1: string, c2: string): string {\r\n        // Simulation: Extract \"values\", add them, re-encrypt.\r\n        // Real CKKS: This would be a coefficient addition.\r\n        const v1 = parseInt(this.decrypt(c1));\r\n        const v2 = parseInt(this.decrypt(c2));\r\n        const result = v1 + v2;\r\n\r\n        return this.encrypt(result).ciphertext;\r\n    }\r\n\r\n    /**\r\n     * Internal helper for simulation logic\r\n     */\r\n    private static decrypt(taggedCiphertext: string): string {\r\n        if (!taggedCiphertext.startsWith(\"CKKS_\")) return \"0\";\r\n\r\n        const hex = taggedCiphertext.replace(\"CKKS_\", \"\");\r\n        const key = crypto.createHash('sha256').update(\"poc-ckks-key\").digest();\r\n\r\n        // In a real PoC, we'd need to track IVs. For simulation, we'll just mock the result.\r\n        // This demonstrates that the ROOM can call 'Add' even if it doesn't have the key.\r\n        // Here the \"Simulator\" represents the Enclave that HAS the key but EXPOSES only its HE methods.\r\n\r\n        // For the sake of the demo, we'll pretend the room performed a logic operation.\r\n        return hex.length > 20 ? \"10\" : \"5\"; // Mocked logic\r\n    }\r\n\r\n    /**\r\n     * Demonstrate a Secure Evaluation\r\n     */\r\n    static processSecureRoom(encryptedUserScore: string, encryptedThreshold: string): string {\r\n        // The \"Room\" performs operation on encrypted data\r\n        const resultCiphertext = this.homomorphicAdd(encryptedUserScore, encryptedThreshold);\r\n\r\n        console.log(`[EVR] Processing encrypted data: ${encryptedUserScore.slice(0, 15)}...`);\r\n\r\n        return resultCiphertext;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\lib\\env.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\lib\\jwt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\lib\\kms.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\middleware\\auth-v2.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\middleware\\memory-zeroizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\installations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\mints.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\packages.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5203,5206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5203,5206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5258,5261],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5258,5261],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * YigYaps Package Routes\n *\n * POST   /v1/packages         â€” Publish a YAP package\n * GET    /v1/packages         â€” Search/list packages\n * GET    /v1/packages/:id     â€” Get package details\n * PATCH  /v1/packages/:id     â€” Update package\n * GET    /v1/packages/by-pkg/:packageId â€” Get by packageId\n *\n * License: Apache 2.0\n */\n\nimport type { FastifyInstance } from \"fastify\";\nimport { z } from \"zod\";\nimport sanitizeHtml from \"sanitize-html\";\nimport {\n  SkillPackageDAL,\n  SkillRuleDAL,\n} from \"@yigyaps/db\";\nimport { requireAuth } from \"../middleware/auth-v2.js\";\n\n// Sanitize HTML configuration - allow safe formatting tags only\nconst sanitizeOptions: sanitizeHtml.IOptions = {\n  allowedTags: [\n    'p', 'br', 'strong', 'em', 'u', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',\n    'ul', 'ol', 'li', 'blockquote', 'code', 'pre', 'a', 'img',\n  ],\n  allowedAttributes: {\n    a: ['href', 'title', 'target', 'rel'],\n    img: ['src', 'alt', 'title', 'width', 'height'],\n    code: ['class'], // for syntax highlighting\n  },\n  allowedSchemes: ['http', 'https', 'mailto'],\n  allowedSchemesByTag: {\n    img: ['https', 'data'], // Only HTTPS images or data URIs\n  },\n  // Remove all event handlers and javascript: protocol\n  disallowedTagsMode: 'discard',\n};\n\nconst createPackageSchema = z.object({\n  packageId: z.string().min(1).max(100),\n  version: z.string().min(1).max(20),\n  displayName: z.string().min(1).max(200),\n  description: z.string().min(10).max(500),\n  readme: z\n    .string()\n    .max(5000)\n    .optional(),\n  authorName: z.string().min(1).max(100),\n  authorUrl: z.string().url().optional(),\n  license: z\n    .enum([\"open-source\", \"free\", \"premium\", \"enterprise\"])\n    .default(\"open-source\"),\n  priceUsd: z.number().min(0).max(9999).default(0),\n  requiresApiKey: z.boolean().default(false),\n  apiKeyInstructions: z.string().max(1000).optional(),\n  category: z\n    .enum([\n      \"development\",\n      \"communication\",\n      \"productivity\",\n      \"research\",\n      \"integration\",\n      \"data\",\n      \"automation\",\n      \"security\",\n      \"ai-ml\",\n      \"personality\",\n      \"wisdom\",\n      \"voice\",\n      \"likeness\",\n      \"other\",\n    ])\n    .default(\"other\"),\n  maturity: z\n    .enum([\"experimental\", \"beta\", \"stable\", \"deprecated\"])\n    .default(\"experimental\"),\n  tags: z.array(z.string().max(50)).max(10).default([]),\n  minRuntimeVersion: z.string().default(\"0.1.0\"),\n  requiredTier: z.number().int().min(0).max(3).default(0),\n  mcpTransport: z.enum([\"stdio\", \"http\", \"sse\"]).default(\"stdio\"),\n  mcpCommand: z.string().max(500).optional(),\n  mcpUrl: z.string().url().optional(),\n  icon: z.string().max(500).optional(),\n  repositoryUrl: z.string().url().optional(),\n  homepageUrl: z.string().url().optional(),\n  rules: z.array(z.object({\n    path: z.string().min(1),\n    content: z.string().min(1),\n  })).optional(),\n});\n\nconst updatePackageSchema = createPackageSchema\n  .partial()\n  .extend({\n    priceUsd: z.number().min(0).max(9999).transform((val) => String(val)).optional(),\n  });\n\nconst searchSchema = z.object({\n  query: z.string().max(200).optional(),\n  category: z\n    .enum([\n      \"development\",\n      \"communication\",\n      \"productivity\",\n      \"research\",\n      \"integration\",\n      \"data\",\n      \"automation\",\n      \"security\",\n      \"ai-ml\",\n      \"personality\",\n      \"wisdom\",\n      \"voice\",\n      \"likeness\",\n      \"other\",\n    ])\n    .optional(),\n  license: z\n    .enum([\"open-source\", \"free\", \"premium\", \"enterprise\"])\n    .optional(),\n  maturity: z\n    .enum([\"experimental\", \"beta\", \"stable\", \"deprecated\"])\n    .optional(),\n  minRating: z.coerce.number().min(0).max(5).optional(),\n  maxPriceUsd: z.coerce.number().min(0).optional(),\n  sortBy: z\n    .enum([\"relevance\", \"popularity\", \"rating\", \"recent\", \"name\"])\n    .default(\"relevance\"),\n  limit: z.coerce.number().int().min(1).max(100).default(20),\n  offset: z.coerce.number().int().min(0).default(0),\n});\n\nexport async function packagesRoutes(fastify: FastifyInstance) {\n  const db = fastify.db;\n  const packageDAL = new SkillPackageDAL(db);\n\n  fastify.post(\n    \"/\",\n    { preHandler: requireAuth() },\n    async (request, reply) => {\n      // Author is automatically set from authenticated user\n      const userId = request.user?.userId;\n      if (!userId) {\n        return reply.code(401).send({ error: \"Unauthorized\" });\n      }\n      const parsed = createPackageSchema.safeParse(request.body);\n      if (!parsed.success) {\n        return reply.code(400).send({\n          error: \"Bad Request\",\n          message: \"Validation failed\",\n          details: parsed.error.issues,\n        });\n      }\n      const body = parsed.data;\n      const now = Date.now();\n\n      const existing = await packageDAL.getByPackageId(body.packageId);\n      if (existing) {\n        return reply\n          .code(409)\n          .send({ error: \"Package ID already exists\", packageId: body.packageId });\n      }\n\n      // Sanitize README to prevent XSS\n      const sanitizedReadme = body.readme\n        ? sanitizeHtml(body.readme, sanitizeOptions)\n        : null;\n\n      const id = `spkg_${now}_${Math.random().toString(36).slice(2, 8)}`;\n      const pkg = await db.transaction(async (tx) => {\n        const pkgDalTx = new SkillPackageDAL(tx as any);\n        const ruleDalTx = new SkillRuleDAL(tx as any);\n\n        const createdPkg = await pkgDalTx.create({\n          id,\n          packageId: body.packageId,\n          version: body.version,\n          displayName: body.displayName,\n          description: body.description,\n          readme: sanitizedReadme,\n          author: userId,\n          authorName: body.authorName,\n          authorUrl: body.authorUrl ?? null,\n          license: body.license,\n          priceUsd: String(body.priceUsd),\n          requiresApiKey: body.requiresApiKey,\n          apiKeyInstructions: body.apiKeyInstructions ?? null,\n          category: body.category,\n          maturity: body.maturity,\n          tags: body.tags,\n          minRuntimeVersion: body.minRuntimeVersion,\n          requiredTier: body.requiredTier,\n          mcpTransport: body.mcpTransport,\n          mcpCommand: body.mcpCommand ?? null,\n          mcpUrl: body.mcpUrl ?? null,\n          icon: body.icon ?? null,\n          repositoryUrl: body.repositoryUrl ?? null,\n          homepageUrl: body.homepageUrl ?? null,\n          origin: \"manual\",\n          createdAt: now,\n          updatedAt: now,\n          releasedAt: now,\n        });\n\n        if (body.rules && body.rules.length > 0) {\n          for (const rule of body.rules) {\n            await ruleDalTx.create({\n              id: `rule_${now}_${Math.random().toString(36).slice(2, 8)}`,\n              packageId: createdPkg.id,\n              path: rule.path,\n              content: rule.content,\n              createdAt: now,\n            });\n          }\n        }\n\n        return createdPkg;\n      });\n\n      return reply.code(201).send(pkg);\n    },\n  );\n\n  fastify.get(\"/\", async (request, reply) => {\n    const params = searchSchema.parse(request.query);\n    const result = await packageDAL.search(params);\n    return reply.send(result);\n  });\n\n  fastify.get<{ Params: { id: string } }>(\n    \"/:id\",\n    async (request, reply) => {\n      const pkg = await packageDAL.getById(request.params.id);\n      if (!pkg) return reply.code(404).send({ error: \"Package not found\" });\n      return reply.send(pkg);\n    },\n  );\n\n  fastify.get<{ Params: { id: string } }>(\n    \"/:id/rules\",\n    async (request, reply) => {\n      const ruleDAL = new SkillRuleDAL(fastify.db);\n      const rules = await ruleDAL.getByPackage(request.params.id);\n      return reply.send({ rules });\n    },\n  );\n\n  fastify.get<{ Params: { packageId: string } }>(\n    \"/by-pkg/:packageId\",\n    async (request, reply) => {\n      const pkg = await packageDAL.getByPackageId(request.params.packageId);\n      if (!pkg) return reply.code(404).send({ error: \"Package not found\" });\n      return reply.send(pkg);\n    },\n  );\n\n  fastify.get<{ Params: { packageId: string } }>(\n    \"/by-pkg/:packageId/rules\",\n    async (request, reply) => {\n      const pkg = await packageDAL.getByPackageId(request.params.packageId);\n      if (!pkg) return reply.code(404).send({ error: \"Package not found\" });\n\n      const ruleDAL = new SkillRuleDAL(fastify.db);\n      const rules = await ruleDAL.getByPackage(pkg.id);\n      return reply.send({ rules });\n    },\n  );\n\n  fastify.patch<{ Params: { id: string } }>(\n    \"/:id\",\n    { preHandler: requireAuth() },\n    async (request, reply) => {\n      const userId = request.user?.userId;\n      if (!userId) {\n        return reply.code(401).send({ error: \"Unauthorized\" });\n      }\n\n      const pkg = await packageDAL.getById(request.params.id);\n      if (!pkg) return reply.code(404).send({ error: \"Package not found\" });\n\n      // Only package owner can update their package\n      if (pkg.author !== userId) {\n        return reply\n          .code(403)\n          .send({ error: \"Not authorized to update this package\" });\n      }\n      const parsed = updatePackageSchema.safeParse(request.body);\n      if (!parsed.success) {\n        return reply.code(400).send({\n          error: \"Bad Request\",\n          message: \"Validation failed\",\n          details: parsed.error.issues,\n        });\n      }\n\n      // Sanitize README if present in update\n      const updateData = { ...parsed.data };\n      if (updateData.readme !== undefined && updateData.readme !== null) {\n        updateData.readme = sanitizeHtml(updateData.readme, sanitizeOptions);\n      }\n\n      const updated = await packageDAL.update(\n        request.params.id,\n        updateData,\n      );\n      return reply.send(updated);\n    },\n  );\n\n  fastify.get(\"/my-packages\", { preHandler: requireAuth() }, async (request, reply) => {\n    const userId = request.user?.userId;\n    if (!userId) {\n      return reply.code(401).send({ error: \"Unauthorized\" });\n    }\n    const packages = await packageDAL.getByAuthor(userId);\n    return reply.send({ packages });\n  });\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\reviews.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\security.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'plaintextRules' is assigned a value but never used.","line":129,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":129,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * YigYaps Security Routes MVP\r\n *\r\n * Implements endpoints to test the Encryption Pipeline (Phase 1)\r\n * and Software Enclave Isolation (Phase 2).\r\n *\r\n * License: Apache 2.0\r\n */\r\n\r\nimport { FastifyPluginAsync } from \"fastify\";\r\nimport { KMS } from \"../lib/kms.js\";\r\nimport { CKKSPoC } from \"../lib/ckks.js\";\r\nimport { SecureBuffer } from \"../middleware/memory-zeroizer.js\";\r\nimport {\r\n    encryptedKnowledgeTable,\r\n    invocationLogsTable,\r\n    ipRegistrationsTable,\r\n} from \"@yigyaps/db\";\r\nimport { eq } from \"drizzle-orm\";\r\nimport crypto from \"crypto\";\r\nimport { randomUUID } from \"crypto\";\r\nimport { z } from \"zod\";\r\nimport { requireAuth } from \"../middleware/auth-v2.js\";\r\n\r\nconst encryptBodySchema = z.object({\r\n    plaintextRules: z.string().max(100_000),\r\n});\r\n\r\nconst paramsSchema = z.object({\r\n    packageId: z.string().min(1),\r\n});\r\n\r\nexport const securityRoutes: FastifyPluginAsync = async (fastify) => {\r\n    /**\r\n     * Encrypt and store knowledge on the edge/client simulator\r\n     * This represents the end of the \"Extraction Pipeline\" where data goes to the Vault.\r\n     */\r\n    fastify.post(\"/knowledge/:packageId\", { preHandler: requireAuth() }, async (request, reply) => {\r\n        const paramsParsed = paramsSchema.safeParse(request.params);\r\n        const bodyParsed = encryptBodySchema.safeParse(request.body);\r\n\r\n        if (!paramsParsed.success || !bodyParsed.success) {\r\n            return reply.code(400).send({\r\n                error: \"Bad Request\",\r\n                message: \"Validation failed\",\r\n                details: paramsParsed.error?.issues || bodyParsed.error?.issues,\r\n            });\r\n        }\r\n\r\n        const { packageId } = paramsParsed.data;\r\n        const { plaintextRules } = bodyParsed.data;\r\n\r\n        // 1. Generate DEK\r\n        const dek = KMS.generateDek();\r\n\r\n        // 2. Encrypt DEK with KEK (KMS Mock)\r\n        const { encryptedDek } = await KMS.encryptDek(dek);\r\n\r\n        // 3. Encrypt Knowledge using DEK\r\n        const contentCiphertext = KMS.encryptKnowledge(plaintextRules, dek);\r\n\r\n        // 4. Hash the original plaintext for IP Registration verification\r\n        const contentHash = crypto.createHash(\"sha256\").update(plaintextRules).digest(\"hex\");\r\n\r\n        // 4b. Mock Blockchain Transaction (Polygon RPC Simulated)\r\n        const mockTxHash = `0x${crypto.randomBytes(32).toString(\"hex\")}`;\r\n        await fastify.db.insert(ipRegistrationsTable).values({\r\n            id: randomUUID(),\r\n            skillPackageId: packageId,\r\n            contentHash,\r\n            blockchainTx: mockTxHash,\r\n            registeredAt: Date.now(),\r\n        });\r\n\r\n        // 5. Save to database\r\n        await fastify.db.insert(encryptedKnowledgeTable).values({\r\n            id: randomUUID(),\r\n            skillPackageId: packageId,\r\n            encryptedDek,\r\n            contentCiphertext,\r\n            contentHash,\r\n            createdAt: Date.now(),\r\n        });\r\n\r\n        // Zeroize the local DEK memory (though JS GC handles it eventually, simulated here)\r\n        // dek.fill(0);\r\n\r\n        return reply.send({ success: true, message: \"Knowledge encrypted and saved.\" });\r\n    });\r\n\r\n    /**\r\n     * Simulate Invocation in the Memory-Only Sandbox\r\n     * Decrypts in SecureBuffer, processes, then zeroizes immediately.\r\n     */\r\n    fastify.post(\"/invoke/:packageId\", { preHandler: requireAuth() }, async (request, reply) => {\r\n        const paramsParsed = paramsSchema.safeParse(request.params);\r\n        if (!paramsParsed.success) {\r\n            return reply.code(400).send({\r\n                error: \"Bad Request\",\r\n                message: \"Validation failed\",\r\n                details: paramsParsed.error.issues,\r\n            });\r\n        }\r\n        const { packageId } = paramsParsed.data;\r\n\r\n        const knowledgeRecords = await fastify.db\r\n            .select()\r\n            .from(encryptedKnowledgeTable)\r\n            .where(eq(encryptedKnowledgeTable.skillPackageId, packageId))\r\n            .limit(1);\r\n\r\n        if (!knowledgeRecords.length) {\r\n            return reply.code(404).send({ error: \"No encrypted knowledge found for this skill.\" });\r\n        }\r\n\r\n        const record = knowledgeRecords[0];\r\n        const encryptedDek = record.encryptedDek;\r\n        const ciphertext = record.contentCiphertext;\r\n\r\n        // Secure Pipeline\r\n        const conclusion = await SecureBuffer.withSecureContext(\r\n            async () => {\r\n                // Fetch DEK securely from KMS\r\n                return await KMS.decryptDek(encryptedDek);\r\n            },\r\n            async (dekBuffer) => {\r\n                // We are now inside the Software Enclave / Sandbox\r\n                // 1. Decrypt knowledge explicitly only in this scope\r\n                const plaintextRules = KMS.decryptKnowledge(ciphertext as Buffer, dekBuffer);\r\n\r\n                // 2. Mock RAG/Rule Engine processing\r\n                // Instead of sending the full plaintextRules to an LLM, we resolve the score locally.\r\n                const mockScore = Math.floor(Math.random() * 10) + 1;\r\n                const generatedConclusion = `Evaluation Score: ${mockScore}/10. Match successful.`;\r\n\r\n                // At the end of this scope, dekBuffer will be wiped by SecureBuffer\r\n                return generatedConclusion;\r\n            }\r\n        );\r\n\r\n        // Log the invocation (Auditing)\r\n        const conclusionHash = crypto.createHash(\"sha256\").update(conclusion).digest(\"hex\");\r\n        await fastify.db.insert(invocationLogsTable).values({\r\n            id: randomUUID(),\r\n            skillPackageId: packageId,\r\n            apiClientId: \"mock-agent-client-id\", // Assume grabbed from Bearer token\r\n            conclusionHash,\r\n            createdAt: Date.now(),\r\n        });\r\n\r\n        // Firewall policy: We ONLY return the conclusion, never the original rules.\r\n        return reply.send({\r\n            success: true,\r\n            conclusion,\r\n            disclaimer: \"Output is sanitized. Original rules were not leaked.\",\r\n        });\r\n    });\r\n\r\n    /**\r\n     * CKKS Homomorphic Encryption PoC\r\n     * Demonstrates computation on encrypted room data.\r\n     */\r\n    fastify.get(\"/ckks-poc\", async (request, reply) => {\r\n        const userScore = 85;\r\n        const threshold = 15;\r\n\r\n        // 1. Client encrypts data before sending\r\n        const encScore = CKKSPoC.encrypt(userScore).ciphertext;\r\n        const encThreshold = CKKSPoC.encrypt(threshold).ciphertext;\r\n\r\n        // 2. Room processes encrypted data\r\n        const encResult = CKKSPoC.processSecureRoom(encScore, encThreshold);\r\n\r\n        return reply.send({\r\n            concept: \"Homomorphic Encryption (CKKS Simulation)\",\r\n            inputs: {\r\n                userScore: \"ENCRYPTED\",\r\n                threshold: \"ENCRYPTED\"\r\n            },\r\n            operation: \"Addition over Ciphertexts\",\r\n            encryptedResult: encResult,\r\n            message: \"The room calculated the sum without ever seeing the numbers 85 or 15.\"\r\n        });\r\n    });\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\routes\\users.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\src\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\api\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\bin\\yigyaps.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\doctor.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\info.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1216,1219],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1216,1219],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from \"vitest\";\r\nimport { infoCommand } from \"../info.js\";\r\nimport * as registry from \"../../lib/registry.js\";\r\n\r\nvi.mock(\"../../lib/registry.js\");\r\nvi.mock(\"../../lib/logger.js\");\r\nvi.mock(\"ora\", () => ({\r\n    default: () => ({\r\n        start: vi.fn().mockReturnValue({ stop: vi.fn(), fail: vi.fn() })\r\n    })\r\n}));\r\n\r\ndescribe(\"infoCommand\", () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n    });\r\n\r\n    it(\"should fetch by packageId and display details\", async () => {\r\n        const mockPkg = {\r\n            id: \"p1\",\r\n            packageId: \"test-skill\",\r\n            displayName: \"Test Skill\",\r\n            version: \"1.0.0\",\r\n            description: \"A cool skill\",\r\n            authorName: \"Author\",\r\n            category: \"tools\",\r\n            maturity: \"stable\",\r\n            license: \"MIT\",\r\n            installCount: 100,\r\n            rating: 4.8,\r\n            ratingCount: 50,\r\n            readme: \"Hello world\"\r\n        };\r\n        const mockClient = {\r\n            getByPackageId: vi.fn().mockResolvedValue(mockPkg),\r\n            getById: vi.fn()\r\n        };\r\n        vi.mocked(registry.createRegistryClient).mockReturnValue(mockClient as any);\r\n\r\n        await infoCommand(\"test-skill\", {});\r\n\r\n        expect(mockClient.getByPackageId).toHaveBeenCalledWith(\"test-skill\");\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\init.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\install.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[702,705],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[702,705],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1140,1143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1140,1143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from \"vitest\";\r\nimport { installCommand } from \"../install.js\";\r\nimport * as registry from \"../../lib/registry.js\";\r\nimport * as auth from \"../../lib/auth.js\";\r\nimport inquirer from \"inquirer\";\r\n\r\nvi.mock(\"../../lib/registry.js\");\r\nvi.mock(\"../../lib/auth.js\");\r\nvi.mock(\"../../lib/logger.js\");\r\nvi.mock(\"inquirer\");\r\nvi.mock(\"ora\", () => ({\r\n    default: () => ({\r\n        start: vi.fn().mockReturnValue({ stop: vi.fn(), fail: vi.fn(), succeed: vi.fn() })\r\n    })\r\n}));\r\n\r\ndescribe(\"installCommand\", () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        vi.mocked(auth.ensureAuthenticated).mockResolvedValue({ id: \"u1\", tier: \"pro\" } as any);\r\n    });\r\n\r\n    it(\"should install a skill with confirmation\", async () => {\r\n        const mockPkg = { id: \"p1\", packageId: \"test-skill\", displayName: \"Test\", version: \"1.0.0\" };\r\n        const mockClient = {\r\n            getByPackageId: vi.fn().mockResolvedValue(mockPkg),\r\n            install: vi.fn().mockResolvedValue({ id: \"inst1\" })\r\n        };\r\n        vi.mocked(registry.createRegistryClient).mockReturnValue(mockClient as any);\r\n        vi.mocked(inquirer.prompt).mockResolvedValue({ confirm: true });\r\n\r\n        await installCommand(\"test-skill\", { agentId: \"agent1\" });\r\n\r\n        expect(mockClient.install).toHaveBeenCalledWith(expect.objectContaining({\r\n            packageId: \"p1\",\r\n            yigbotId: \"agent1\"\r\n        }));\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\list.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\login.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\publish.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1389,1392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1389,1392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1614,1617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1614,1617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2291,2294],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2291,2294],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2435,2438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2435,2438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from \"vitest\";\r\nimport { publishCommand } from \"../publish.js\";\r\nimport * as auth from \"../../lib/auth.js\";\r\nimport * as packager from \"../../lib/packager.js\";\r\nimport * as registry from \"../../lib/registry.js\";\r\n\r\nvi.mock(\"../../lib/auth.js\");\r\nvi.mock(\"../../lib/packager.js\");\r\nvi.mock(\"../../lib/registry.js\");\r\nvi.mock(\"../../lib/logger.js\");\r\nvi.mock(\"../validate.js\", () => ({\r\n    validateCommand: vi.fn().mockResolvedValue(undefined)\r\n}));\r\nvi.mock(\"ora\", () => ({\r\n    default: () => ({\r\n        start: vi.fn().mockReturnValue({ succeed: vi.fn(), fail: vi.fn() })\r\n    })\r\n}));\r\n\r\ndescribe(\"publishCommand\", () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        vi.mocked(auth.ensureAuthenticated).mockResolvedValue({\r\n            id: \"u1\", displayName: \"User\", githubUsername: \"user\", email: \"\", avatarUrl: \"\", tier: \"free\", role: \"user\", isVerifiedCreator: true, totalPackages: 0, totalEarningsUsd: \"0\"\r\n        });\r\n    });\r\n\r\n    it(\"should pack and publish locally built payload\", async () => {\r\n        const mockPayload = {\r\n            manifest: { name: \"test-skill\", version: \"1.0.0\", description: \"test and some more chars so it passes\", author: \"test\" },\r\n            rules: [{ path: \"rule1.md\", content: \"content\" }]\r\n        };\r\n        vi.mocked(packager.packPackage).mockResolvedValue(mockPayload as any);\r\n\r\n        const mockClient = {\r\n            publishPackage: vi.fn().mockResolvedValue({ id: \"p1\", packageId: \"test-skill\" })\r\n        };\r\n        vi.mocked(registry.createPublisherClient).mockReturnValue(mockClient as any);\r\n\r\n        await publishCommand({});\r\n\r\n        expect(packager.packPackage).toHaveBeenCalled();\r\n        expect(mockClient.publishPackage).toHaveBeenCalledWith(expect.objectContaining({\r\n            packageId: \"test-skill\",\r\n            version: \"1.0.0\",\r\n            rules: [{ path: \"rule1.md\", content: \"content\" }]\r\n        }));\r\n    });\r\n\r\n    it(\"should handle dry-run without uploading\", async () => {\r\n        const mockPayload = {\r\n            manifest: { name: \"test-skill\", version: \"1.0.0\", description: \"test and some more chars\", author: \"test\" },\r\n            rules: []\r\n        };\r\n        vi.mocked(packager.packPackage).mockResolvedValue(mockPayload as any);\r\n        const mockClient = { publishPackage: vi.fn() };\r\n        vi.mocked(registry.createPublisherClient).mockReturnValue(mockClient as any);\r\n\r\n        await publishCommand({ dryRun: true });\r\n\r\n        expect(mockClient.publishPackage).not.toHaveBeenCalled();\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\run.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\search.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[961,964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[961,964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1415,1418],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1415,1418],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from \"vitest\";\r\nimport { searchCommand } from \"../search.js\";\r\nimport * as registry from \"../../lib/registry.js\";\r\n\r\nvi.mock(\"../../lib/registry.js\");\r\nvi.mock(\"../../lib/logger.js\");\r\nvi.mock(\"ora\", () => ({\r\n    default: () => ({\r\n        start: vi.fn().mockReturnValue({ stop: vi.fn(), fail: vi.fn() })\r\n    })\r\n}));\r\n\r\ndescribe(\"searchCommand\", () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n    });\r\n\r\n    it(\"should display results in a table\", async () => {\r\n        const mockResult = {\r\n            packages: [\r\n                { packageId: \"skill-1\", displayName: \"Skill 1\", version: \"1.0.0\", authorName: \"Dev\", installCount: 10 }\r\n            ],\r\n            total: 1,\r\n            limit: 10,\r\n            offset: 0\r\n        };\r\n        const mockClient = { search: vi.fn().mockResolvedValue(mockResult) };\r\n        vi.mocked(registry.createRegistryClient).mockReturnValue(mockClient as any);\r\n\r\n        await searchCommand(\"test\", {});\r\n\r\n        expect(mockClient.search).toHaveBeenCalledWith(expect.objectContaining({ query: \"test\" }));\r\n    });\r\n\r\n    it(\"should handle empty results\", async () => {\r\n        const mockResult = { packages: [], total: 0, limit: 10, offset: 0 };\r\n        const mockClient = { search: vi.fn().mockResolvedValue(mockResult) };\r\n        vi.mocked(registry.createRegistryClient).mockReturnValue(mockClient as any);\r\n\r\n        await searchCommand(\"nonexistent\", {});\r\n\r\n        expect(mockClient.search).toHaveBeenCalled();\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\status.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1079,1082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1079,1082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1456,1459],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1456,1459],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from \"vitest\";\r\nimport { statusCommand } from \"../status.js\";\r\nimport * as registry from \"../../lib/registry.js\";\r\nimport { CliError } from \"../../lib/errors.js\";\r\n\r\nvi.mock(\"../../lib/registry.js\");\r\nvi.mock(\"../../lib/logger.js\");\r\nvi.mock(\"ora\", () => ({\r\n    default: () => ({\r\n        start: vi.fn().mockReturnValue({ stop: vi.fn(), fail: vi.fn() })\r\n    })\r\n}));\r\n\r\ndescribe(\"statusCommand\", () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n    });\r\n\r\n    it(\"should display status for existing package\", async () => {\r\n        const mockPkg = {\r\n            id: \"spkg_123\",\r\n            packageId: \"test-skill\",\r\n            displayName: \"Test Skill\",\r\n            version: \"1.0.0\",\r\n            authorName: \"Owner\",\r\n            maturity: \"stable\",\r\n            installCount: 5,\r\n            rating: 4.5,\r\n            ratingCount: 10\r\n        };\r\n        const mockClient = { getByPackageId: vi.fn().mockResolvedValue(mockPkg) };\r\n        vi.mocked(registry.createRegistryClient).mockReturnValue(mockClient as any);\r\n\r\n        await statusCommand(\"test-skill\");\r\n\r\n        expect(mockClient.getByPackageId).toHaveBeenCalledWith(\"test-skill\");\r\n    });\r\n\r\n    it(\"should handle non-existent package\", async () => {\r\n        const mockClient = { getByPackageId: vi.fn().mockRejectedValue(new Error(\"404\")) };\r\n        vi.mocked(registry.createRegistryClient).mockReturnValue(mockClient as any);\r\n\r\n        await expect(statusCommand(\"missing\")).rejects.toThrow(CliError);\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\uninstall.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\__tests__\\validate.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1341,1344],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1341,1344],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1412,1415],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1412,1415],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach } from \"vitest\";\r\nimport { validateCommand } from \"../validate.js\";\r\nimport fs from \"fs-extra\";\r\nimport { CliError } from \"../../lib/errors.js\";\r\n\r\nvi.mock(\"fs-extra\");\r\nvi.mock(\"../../lib/logger.js\");\r\n\r\ndescribe(\"validateCommand\", () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n    });\r\n\r\n    it(\"should throw if package.json is missing\", async () => {\r\n        vi.mocked(fs.pathExists).mockResolvedValue(false as never);\r\n        await expect(validateCommand()).rejects.toThrow(CliError);\r\n    });\r\n\r\n    it(\"should throw if manifest is invalid\", async () => {\r\n        vi.mocked(fs.pathExists).mockResolvedValue(true as never);\r\n        vi.mocked(fs.readJson).mockResolvedValue({ name: \"invalid\" }); // Small description missing\r\n        await expect(validateCommand()).rejects.toThrow(CliError);\r\n    });\r\n\r\n    it(\"should pass if everything is valid\", async () => {\r\n        vi.mocked(fs.pathExists).mockResolvedValue(true as never);\r\n        vi.mocked(fs.readJson).mockResolvedValue({\r\n            name: \"test-skill\",\r\n            version: \"1.0.0\",\r\n            description: \"A very long description that passes validation.\",\r\n            author: \"test\",\r\n            license: \"MIT\"\r\n        });\r\n        vi.mocked(fs.stat).mockResolvedValue({ isDirectory: () => true } as any);\r\n        vi.mocked(fs.readdir).mockResolvedValue([\"rule1.md\"] as any);\r\n\r\n        await expect(validateCommand()).resolves.not.toThrow();\r\n    });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\dev.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2034,2037],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2034,2037],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import chokidar from \"chokidar\";\r\nimport path from \"path\";\r\nimport { logger } from \"../lib/logger.js\";\r\nimport { CliError } from \"../lib/errors.js\";\r\nimport { packPackage } from \"../lib/packager.js\";\r\nimport { SkillSandbox } from \"../lib/sandbox.js\";\r\n\r\n/**\r\n * Dev Command\r\n */\r\nexport async function devCommand() {\r\n    const cwd = process.cwd();\r\n\r\n    logger.info(\"ðŸ”§  Starting YigYaps skill sandbox...\");\r\n\r\n    try {\r\n        // Initial pack\r\n        let payload = await packPackage(cwd);\r\n        const sandbox = new SkillSandbox(payload);\r\n\r\n        logger.success(`  âœ… Loaded ${payload.manifest.name} v${payload.manifest.version}`);\r\n        logger.info(`  ðŸ“„ Rule files watched: ${payload.rules.length}`);\r\n        console.log(\"\\n  Test with: claude --mcp-server \\\"yigyaps dev-server\\\"\");\r\n        logger.hint(\"Use 'yigyaps dev-server' for standard-io based MCP client connections.\");\r\n\r\n        // Setup file watcher for hot-reloading\r\n        const watcher = chokidar.watch([\r\n            path.join(cwd, \"package.json\"),\r\n            path.join(cwd, \"rules/**/*\"),\r\n            path.join(cwd, \"README.md\")\r\n        ], {\r\n            ignoreInitial: true,\r\n            persistent: true\r\n        });\r\n\r\n        watcher.on(\"change\", async (filePath) => {\r\n            const relativePath = path.relative(cwd, filePath);\r\n            logger.info(`\\nðŸ”„  File changed: ${relativePath}. Reloading...`);\r\n\r\n            try {\r\n                payload = await packPackage(cwd);\r\n                sandbox.updatePayload(payload);\r\n                logger.success(`  âœ… Reloaded ${payload.manifest.name}`);\r\n            } catch (err: unknown) {\r\n                const message = err instanceof Error ? err.message : String(err);\r\n                logger.error(`  âŒ Failed to reload: ${message}`);\r\n            }\r\n        });\r\n\r\n        // Keep process alive\r\n        process.on(\"SIGINT\", () => {\r\n            watcher.close();\r\n            logger.info(\"\\nStopping sandbox...\");\r\n            process.exit(0);\r\n        });\r\n\r\n    } catch (error: any) {\r\n        if (error instanceof CliError) throw error;\r\n        throw CliError.system(`Sandbox failed to start: ${error.message}`);\r\n    }\r\n}\r\n\r\n/**\r\n * Dev Server Command (StdIO mode for MCP clients)\r\n * This sits in the background when an MCP client connects.\r\n */\r\nexport async function devServerCommand() {\r\n    try {\r\n        const payload = await packPackage(process.cwd());\r\n        const sandbox = new SkillSandbox(payload);\r\n        await sandbox.start();\r\n    } catch {\r\n        process.exit(1);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\doctor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\info.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\init.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\install.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\list.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\login.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\logout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\mcp.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\publish.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\run.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1851,1854],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1851,1854],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from \"../lib/logger.js\";\r\nimport { CliError } from \"../lib/errors.js\";\r\nimport { createRegistryClient } from \"../lib/registry.js\";\r\nimport { SkillSandbox } from \"../lib/sandbox.js\";\r\nimport chalk from \"chalk\";\r\n\r\ninterface RunOptions {\r\n    verbose?: boolean;\r\n}\r\n\r\n/**\r\n * Run Command\r\n * \r\n * Start a local MCP sandbox for a remote skill.\r\n */\r\nexport async function runCommand(id: string, _options: RunOptions) {\r\n    try {\r\n        const client = createRegistryClient();\r\n\r\n        const ora = (await import(\"ora\")).default;\r\n        const spinner = ora(`Preparing to run skill '${id}'...`).start();\r\n\r\n        try {\r\n            // 1. Fetch Skill Info\r\n            let pkg;\r\n            try {\r\n                pkg = await client.getByPackageId(id);\r\n            } catch {\r\n                pkg = await client.getById(id);\r\n            }\r\n\r\n            // 2. Fetch Rules\r\n            const { rules } = await client.getRules(pkg.id);\r\n\r\n            spinner.succeed(`Loaded skill '${pkg.displayName}' v${pkg.version}`);\r\n\r\n            // 3. Start Sandbox\r\n            logger.info(chalk.cyan(`\\nðŸš€ Starting Local MCP Sandbox...`));\r\n            logger.info(chalk.gray(`Skill: ${pkg.displayName} (${pkg.packageId})`));\r\n            logger.info(chalk.gray(`Author: ${pkg.authorName}`));\r\n            logger.info(chalk.gray(`Transport: stdio`));\r\n\r\n            console.log(chalk.yellow(`\\n[WARNING] This is a temporary sandbox via stdio.`));\r\n            console.log(chalk.yellow(`To exit, press Ctrl+C.\\n`));\r\n\r\n            const sandbox = new SkillSandbox({\r\n                manifest: {\r\n                    name: pkg.packageId,\r\n                    version: pkg.version,\r\n                    description: pkg.description,\r\n                    author: pkg.authorName,\r\n                    category: pkg.category\r\n                } as any,\r\n                rules: rules\r\n            });\r\n\r\n            await sandbox.start();\r\n\r\n        } catch (err: unknown) {\r\n            spinner.fail(\"Failed to load skill.\");\r\n            const message = err instanceof Error ? err.message : String(err);\r\n            throw CliError.network(`Could not run skill: ${message}`);\r\n        }\r\n    } catch (error: unknown) {\r\n        if (error instanceof CliError) throw error;\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        throw CliError.system(`Run command failed: ${message}`);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\search.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[791,794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[791,794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { logger } from \"../lib/logger.js\";\r\nimport { CliError } from \"../lib/errors.js\";\r\nimport { createRegistryClient } from \"../lib/registry.js\";\r\nimport Table from \"cli-table3\";\r\n\r\ninterface SearchOptions {\r\n    category?: string;\r\n    limit?: string;\r\n    json?: boolean;\r\n}\r\n\r\n/**\r\n * Search Command\r\n * \r\n * Find skills in the YigYaps registry.\r\n */\r\nexport async function searchCommand(query: string | undefined, options: SearchOptions) {\r\n    try {\r\n        const client = createRegistryClient();\r\n\r\n        const ora = (await import(\"ora\")).default;\r\n        const spinner = options.json ? null : ora(\"Searching YigYaps Registry...\").start();\r\n\r\n        try {\r\n            const result = await client.search({\r\n                query,\r\n                category: options.category as any,\r\n                limit: options.limit ? parseInt(options.limit) : 10,\r\n            });\r\n\r\n            if (spinner) spinner.stop();\r\n\r\n            if (options.json) {\r\n                console.log(JSON.stringify(result, null, 2));\r\n                return;\r\n            }\r\n\r\n            if (result.packages.length === 0) {\r\n                logger.info(\"No skills found matching your query.\");\r\n                return;\r\n            }\r\n\r\n            logger.info(`Found ${result.total} skill(s):`);\r\n\r\n            const table = new Table({\r\n                head: [\"ID\", \"Name\", \"Version\", \"Author\", \"Installs\"],\r\n                style: { head: [\"cyan\", \"bold\"], border: [\"gray\"] }\r\n            });\r\n\r\n            for (const pkg of result.packages) {\r\n                table.push([\r\n                    pkg.packageId,\r\n                    pkg.displayName,\r\n                    `v${pkg.version}`,\r\n                    pkg.authorName,\r\n                    pkg.installCount || 0\r\n                ]);\r\n            }\r\n\r\n            console.log(table.toString());\r\n            console.log(`\\nUse 'yigyaps info <id>' to see details about a skill.`);\r\n\r\n        } catch (err: unknown) {\r\n            if (spinner) spinner.fail(\"Search failed.\");\r\n            const message = err instanceof Error ? err.message : String(err);\r\n            throw CliError.network(`Search failed: ${message}`);\r\n        }\r\n    } catch (error: unknown) {\r\n        if (error instanceof CliError) throw error;\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        throw CliError.system(`Search command failed: ${message}`);\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\status.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\uninstall.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\validate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\commands\\whoami.ts","messages":[{"ruleId":"no-useless-catch","severity":2,"message":"Unnecessary try/catch wrapper.","line":8,"column":5,"nodeType":"TryStatement","messageId":"unnecessaryCatch","endLine":21,"endColumn":6},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[678,681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[678,681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ensureAuthenticated } from \"../lib/auth.js\";\r\nimport { logger } from \"../lib/logger.js\";\r\n\r\n/**\r\n * Whoami Command\r\n */\r\nexport async function whoamiCommand() {\r\n    try {\r\n        const user = await ensureAuthenticated();\r\n\r\n        logger.info(\"YigYaps â€” Current Session\");\r\n        console.log(`\\nðŸ‘¤ Logged in as: ${user.displayName} (@${user.githubUsername})`);\r\n        console.log(`   ID:   ${user.id}`);\r\n        console.log(`   Tier: ${user.tier}`);\r\n        console.log(`   Role: ${user.role}`);\r\n        console.log(`\\n   Skills:   ${user.totalPackages ?? 0}`);\r\n        console.log(`   Earnings: $${user.totalEarningsUsd ?? \"0.00\"}\\n`);\r\n    } catch (error: any) {\r\n        // ensureAuthenticated throws CliError if not logged in\r\n        throw error;\r\n    }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\__tests__\\errors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\errors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\packager.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[328,331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[328,331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import fs from \"fs-extra\";\r\nimport path from \"path\";\r\nimport { CliError } from \"./errors.js\";\r\nimport { manifestSchema } from \"../commands/validate.js\";\r\n\r\n/**\r\n * Packager Helpers\r\n */\r\n\r\nexport interface RuleFile {\r\n    path: string;\r\n    content: string;\r\n}\r\n\r\nexport interface PackagePayload {\r\n    manifest: Record<string, any>;\r\n    rules: RuleFile[];\r\n    readme?: string;\r\n}\r\n\r\n/**\r\n * Reads the current directory and packs it into a payload.\r\n * Assumes valid structure (caller should run validate command first if unsure).\r\n */\r\nexport async function packPackage(cwd: string): Promise<PackagePayload> {\r\n    const packageJsonPath = path.join(cwd, \"package.json\");\r\n    if (!fs.existsSync(packageJsonPath)) {\r\n        throw CliError.user(\"package.json not found in current directory.\");\r\n    }\r\n\r\n    // 1. Read and parse package.json\r\n    const rawManifest = await fs.readJson(packageJsonPath);\r\n    const parsed = manifestSchema.safeParse(rawManifest);\r\n    if (!parsed.success) {\r\n        throw CliError.user(\"Invalid package.json manifest.\");\r\n    }\r\n    const manifest = parsed.data;\r\n\r\n    // 2. Read rules/ directory\r\n    const rulesDir = path.join(cwd, \"rules\");\r\n    if (!fs.existsSync(rulesDir)) {\r\n        throw CliError.user(\"rules/ directory not found.\");\r\n    }\r\n\r\n    const ruleFiles: RuleFile[] = [];\r\n    const files = await fs.readdir(rulesDir);\r\n    for (const file of files) {\r\n        if (file.endsWith(\".md\") || file.endsWith(\".txt\")) {\r\n            const content = await fs.readFile(path.join(rulesDir, file), \"utf-8\");\r\n            ruleFiles.push({\r\n                path: file,\r\n                content\r\n            });\r\n        }\r\n    }\r\n\r\n    if (ruleFiles.length === 0) {\r\n        throw CliError.user(\"No rule files (.md or .txt) found in rules/ directory.\");\r\n    }\r\n\r\n    // 3. Read optional README.md\r\n    let readme: string | undefined;\r\n    const readmePath = path.join(cwd, \"README.md\");\r\n    if (fs.existsSync(readmePath)) {\r\n        readme = await fs.readFile(readmePath, \"utf-8\");\r\n    }\r\n\r\n    return {\r\n        manifest,\r\n        rules: ruleFiles,\r\n        readme\r\n    };\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\src\\lib\\sandbox.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\cli\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\client\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\client\\src\\publisher-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\client\\src\\registry-client.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3253,3256],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3253,3256],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3504,3507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3504,3507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4329,4332],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4329,4332],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4384,4387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4384,4387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":133,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4610,4613],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4610,4613],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * YigYaps Registry Client â€” for Skill Consumers\n *\n * Used by MCP clients (Yigcore, Claude Code, Cursor, etc.) to search\n * and retrieve skill packages from the YigYaps registry.\n *\n * License: Apache 2.0\n */\n\nimport type {\n  SkillPackage,\n  SkillPackageSearchQuery,\n  SkillPackageSearchResult,\n  McpRegistryDiscovery,\n} from \"@yigyaps/types\";\n\nexport interface RegistryClientOptions {\n  baseUrl?: string;\n  apiKey?: string;\n  timeout?: number;\n}\n\nexport class YigYapsRegistryClient {\n  private baseUrl: string;\n  private headers: Record<string, string>;\n\n  constructor(options: RegistryClientOptions = {}) {\n    this.baseUrl = options.baseUrl ?? \"https://api.yigyaps.com\";\n    this.headers = {\n      \"Content-Type\": \"application/json\",\n      ...(options.apiKey ? { Authorization: `Bearer ${options.apiKey}` } : {}),\n    };\n  }\n\n  async getDiscovery(): Promise<McpRegistryDiscovery> {\n    const res = await fetch(`${this.baseUrl}/.well-known/mcp.json`, {\n      headers: this.headers,\n    });\n    if (!res.ok) throw new Error(`YigYaps discovery failed: ${res.status}`);\n    return res.json() as Promise<McpRegistryDiscovery>;\n  }\n\n  async search(\n    query: SkillPackageSearchQuery,\n  ): Promise<SkillPackageSearchResult> {\n    const params = new URLSearchParams();\n    if (query.query) params.set(\"query\", query.query);\n    if (query.category) params.set(\"category\", query.category);\n    if (query.license) params.set(\"license\", query.license);\n    if (query.maturity) params.set(\"maturity\", query.maturity);\n    if (query.sortBy) params.set(\"sortBy\", query.sortBy);\n    if (query.limit != null) params.set(\"limit\", String(query.limit));\n    if (query.offset != null) params.set(\"offset\", String(query.offset));\n\n    const res = await fetch(`${this.baseUrl}/v1/packages?${params}`, {\n      headers: this.headers,\n    });\n    if (!res.ok) throw new Error(`YigYaps search failed: ${res.status}`);\n    return res.json() as Promise<SkillPackageSearchResult>;\n  }\n\n  async getById(id: string): Promise<SkillPackage> {\n    const res = await fetch(`${this.baseUrl}/v1/packages/${id}`, {\n      headers: this.headers,\n    });\n    if (!res.ok) throw new Error(`YigYaps getById failed: ${res.status}`);\n    return res.json() as Promise<SkillPackage>;\n  }\n\n  async getByPackageId(packageId: string): Promise<SkillPackage> {\n    const res = await fetch(\n      `${this.baseUrl}/v1/packages/by-pkg/${encodeURIComponent(packageId)}`,\n      { headers: this.headers },\n    );\n    if (!res.ok) throw new Error(`YigYaps getByPackageId failed: ${res.status}`);\n    return res.json() as Promise<SkillPackage>;\n  }\n\n  async install(params: {\n    packageId: string;\n    yigbotId: string;\n    userTier?: string;\n    configuration?: Record<string, unknown>;\n  }): Promise<{ id: string; status: string }> {\n    const res = await fetch(`${this.baseUrl}/v1/installations`, {\n      method: \"POST\",\n      headers: this.headers,\n      body: JSON.stringify(params),\n    });\n    if (!res.ok) {\n      const err = await res.json().catch(() => ({}));\n      throw new Error(\n        `YigYaps install failed: ${res.status} ${JSON.stringify(err)}`,\n      );\n    }\n    return res.json() as Promise<{ id: string; status: string }>;\n  }\n\n  async getInstallations(): Promise<{ installations: any[] }> {\n    const res = await fetch(`${this.baseUrl}/v1/installations/me`, {\n      headers: this.headers,\n    });\n    if (!res.ok) throw new Error(`YigYaps getInstallations failed: ${res.status}`);\n    return res.json() as Promise<{ installations: any[] }>;\n  }\n\n  async uninstall(id: string): Promise<void> {\n    const res = await fetch(`${this.baseUrl}/v1/installations/${id}`, {\n      method: \"DELETE\",\n      headers: this.headers,\n    });\n    if (!res.ok) throw new Error(`YigYaps uninstall failed: ${res.status}`);\n  }\n\n  async getRules(packageIdOrId: string): Promise<{ rules: { path: string; content: string }[] }> {\n    const isUuid = packageIdOrId.includes(\"-\") || packageIdOrId.startsWith(\"spkg_\");\n    const endpoint = isUuid\n      ? `/v1/packages/${packageIdOrId}/rules`\n      : `/v1/packages/by-pkg/${encodeURIComponent(packageIdOrId)}/rules`;\n\n    const res = await fetch(`${this.baseUrl}${endpoint}`, {\n      headers: this.headers,\n    });\n    if (!res.ok) throw new Error(`YigYaps getRules failed: ${res.status}`);\n    return res.json() as Promise<{ rules: any[] }>;\n  }\n\n  async getMe(): Promise<Record<string, any>> {\n    const res = await fetch(`${this.baseUrl}/v1/auth/me`, {\n      headers: this.headers,\n    });\n    if (!res.ok) throw new Error(`YigYaps getMe failed: ${res.status}`);\n    return res.json() as Promise<Record<string, any>>;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\client\\src\\security-client.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\__tests__\\dal\\skill-package-dal.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\__tests__\\helpers\\factories.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\__tests__\\helpers\\global-setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\__tests__\\helpers\\setup-env.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\__tests__\\helpers\\test-db.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\__tests__\\helpers\\test-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\drizzle.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\dal\\error-utils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\dal\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\dal\\skill-package-dal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\dal\\user-dal.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\schema\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\schema\\security.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'uuid' is defined but never used.","line":17,"column":5,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":9,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"uuid"},"fix":{"range":[288,299],"text":""},"desc":"Remove unused variable \"uuid\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * YigYaps Database Schema â€” Security and Telemetry\r\n *\r\n * Drizzle ORM table definitions for the YigYaps MVP Security Strategy.\r\n * Tables use the `yy_` prefix.\r\n *\r\n * License: Apache 2.0\r\n */\r\n\r\nimport {\r\n    pgTable,\r\n    text,\r\n    bigint,\r\n    integer,\r\n    numeric,\r\n    index,\r\n    uuid,\r\n    customType,\r\n} from \"drizzle-orm/pg-core\";\r\n\r\nimport { skillPackagesTable } from \"./skill-packages.js\";\r\n\r\n// Custom type for bytea\r\nconst buffer = customType<{ data: Buffer; driverData: string }>({\r\n    dataType() {\r\n        return 'bytea';\r\n    },\r\n    toDriver(val: Buffer): string {\r\n        return '\\\\x' + val.toString('hex');\r\n    },\r\n    fromDriver(value: string): Buffer {\r\n        if (value.startsWith('\\\\x')) {\r\n            return Buffer.from(value.slice(2), 'hex');\r\n        }\r\n        return Buffer.from(value, 'hex');\r\n    },\r\n});\r\n\r\nexport const encryptedKnowledgeTable = pgTable(\r\n    \"yy_encrypted_knowledge\",\r\n    {\r\n        id: text(\"id\").primaryKey(), // using text to match skill-packages style\r\n        skillPackageId: text(\"skill_package_id\")\r\n            .notNull()\r\n            .references(() => skillPackagesTable.id, { onDelete: \"cascade\" }),\r\n        encryptedDek: text(\"encrypted_dek\").notNull(),\r\n        contentCiphertext: buffer(\"content_ciphertext\").notNull(),\r\n        contentHash: text(\"content_hash\").notNull(),\r\n        version: integer(\"version\").notNull().default(1),\r\n        createdAt: bigint(\"created_at\", { mode: \"number\" }).notNull(),\r\n    },\r\n    (table) => [\r\n        index(\"idx_yy_encrypted_knowledge_package\").on(table.skillPackageId),\r\n    ],\r\n);\r\n\r\nexport type EncryptedKnowledgeRow = typeof encryptedKnowledgeTable.$inferSelect;\r\nexport type EncryptedKnowledgeInsert = typeof encryptedKnowledgeTable.$inferInsert;\r\n\r\nexport const invocationLogsTable = pgTable(\r\n    \"yy_invocation_logs\",\r\n    {\r\n        id: text(\"id\").primaryKey(),\r\n        skillPackageId: text(\"skill_package_id\").notNull(),\r\n        apiClientId: text(\"api_client_id\").notNull(),\r\n        costUsd: numeric(\"cost_usd\", { precision: 10, scale: 4 }),\r\n        expertSplit: numeric(\"expert_split\", { precision: 10, scale: 4 }),\r\n        inferenceMs: integer(\"inference_ms\"),\r\n        conclusionHash: text(\"conclusion_hash\").notNull(),\r\n        createdAt: bigint(\"created_at\", { mode: \"number\" }).notNull(),\r\n    },\r\n    (table) => [\r\n        index(\"idx_yy_invocation_logs_package\").on(table.skillPackageId),\r\n        index(\"idx_yy_invocation_logs_client\").on(table.apiClientId),\r\n    ],\r\n);\r\n\r\nexport type InvocationLogRow = typeof invocationLogsTable.$inferSelect;\r\nexport type InvocationLogInsert = typeof invocationLogsTable.$inferInsert;\r\n\r\nexport const ipRegistrationsTable = pgTable(\r\n    \"yy_ip_registrations\",\r\n    {\r\n        id: text(\"id\").primaryKey(),\r\n        skillPackageId: text(\"skill_package_id\")\r\n            .notNull()\r\n            .references(() => skillPackagesTable.id, { onDelete: \"cascade\" }),\r\n        contentHash: text(\"content_hash\").notNull(),\r\n        blockchainTx: text(\"blockchain_tx\").notNull(),\r\n        registeredAt: bigint(\"registered_at\", { mode: \"number\" }).notNull(),\r\n    },\r\n    (table) => [\r\n        index(\"idx_yy_ip_registrations_package\").on(table.skillPackageId),\r\n    ],\r\n);\r\n\r\nexport type IpRegistrationRow = typeof ipRegistrationsTable.$inferSelect;\r\nexport type IpRegistrationInsert = typeof ipRegistrationsTable.$inferInsert;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\schema\\skill-packages.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\src\\schema\\users.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\db\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\types\\src\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\types\\src\\registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\types\\src\\skill-mint.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\packages\\types\\src\\skill-package.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\scripts\\migrate.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\scripts\\test-kms-core.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\scripts\\test-mvp-security.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\gaoyu\\Documents\\GitHub\\yigyaps\\vitest.workspace.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]